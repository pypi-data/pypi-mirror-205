
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.time
import java.util
import java.util.concurrent
import java.util.function
import jpype.protocol
import org.optaplanner.core.api.domain.common
import org.optaplanner.core.api.domain.solution.cloner
import org.optaplanner.core.api.score.calculator
import org.optaplanner.core.api.score.stream
import org.optaplanner.core.config
import org.optaplanner.core.config.phase
import org.optaplanner.core.config.score.director
import org.optaplanner.core.config.solver.monitoring
import org.optaplanner.core.config.solver.random
import org.optaplanner.core.config.solver.termination
import org.optaplanner.core.impl.domain.common.accessor
import org.optaplanner.core.impl.solver.random
import typing



class EnvironmentMode(java.lang.Enum['EnvironmentMode']):
    FULL_ASSERT: typing.ClassVar['EnvironmentMode'] = ...
    NON_INTRUSIVE_FULL_ASSERT: typing.ClassVar['EnvironmentMode'] = ...
    FAST_ASSERT: typing.ClassVar['EnvironmentMode'] = ...
    REPRODUCIBLE: typing.ClassVar['EnvironmentMode'] = ...
    NON_REPRODUCIBLE: typing.ClassVar['EnvironmentMode'] = ...
    def isAsserted(self) -> bool: ...
    def isIntrusiveFastAsserted(self) -> bool: ...
    def isNonIntrusiveFullAsserted(self) -> bool: ...
    def isReproducible(self) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'EnvironmentMode': ...
    @staticmethod
    def values() -> typing.MutableSequence['EnvironmentMode']: ...

class SolverConfig(org.optaplanner.core.config.AbstractConfig['SolverConfig']):
    XML_ELEMENT_NAME: typing.ClassVar[str] = ...
    XML_NAMESPACE: typing.ClassVar[str] = ...
    XML_TYPE_NAME: typing.ClassVar[str] = ...
    MOVE_THREAD_COUNT_NONE: typing.ClassVar[str] = ...
    MOVE_THREAD_COUNT_AUTO: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, classLoader: java.lang.ClassLoader): ...
    @typing.overload
    def __init__(self, solverConfig: 'SolverConfig'): ...
    def copyConfig(self) -> 'SolverConfig': ...
    @typing.overload
    @staticmethod
    def createFromXmlFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> 'SolverConfig': ...
    @typing.overload
    @staticmethod
    def createFromXmlFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath], classLoader: java.lang.ClassLoader) -> 'SolverConfig': ...
    @typing.overload
    @staticmethod
    def createFromXmlInputStream(inputStream: java.io.InputStream) -> 'SolverConfig': ...
    @typing.overload
    @staticmethod
    def createFromXmlInputStream(inputStream: java.io.InputStream, classLoader: java.lang.ClassLoader) -> 'SolverConfig': ...
    @typing.overload
    @staticmethod
    def createFromXmlReader(reader: java.io.Reader) -> 'SolverConfig': ...
    @typing.overload
    @staticmethod
    def createFromXmlReader(reader: java.io.Reader, classLoader: java.lang.ClassLoader) -> 'SolverConfig': ...
    @typing.overload
    @staticmethod
    def createFromXmlResource(string: str) -> 'SolverConfig': ...
    @typing.overload
    @staticmethod
    def createFromXmlResource(string: str, classLoader: java.lang.ClassLoader) -> 'SolverConfig': ...
    def determineDomainAccessType(self) -> org.optaplanner.core.api.domain.common.DomainAccessType: ...
    def determineEnvironmentMode(self) -> EnvironmentMode: ...
    def determineMetricConfig(self) -> org.optaplanner.core.config.solver.monitoring.MonitoringConfig: ...
    def getClassLoader(self) -> java.lang.ClassLoader: ...
    def getDaemon(self) -> bool: ...
    def getDomainAccessType(self) -> org.optaplanner.core.api.domain.common.DomainAccessType: ...
    def getEntityClassList(self) -> java.util.List[typing.Type[typing.Any]]: ...
    def getEnvironmentMode(self) -> EnvironmentMode: ...
    def getGizmoMemberAccessorMap(self) -> java.util.Map[str, org.optaplanner.core.impl.domain.common.accessor.MemberAccessor]: ...
    def getGizmoSolutionClonerMap(self) -> java.util.Map[str, org.optaplanner.core.api.domain.solution.cloner.SolutionCloner]: ...
    def getMonitoringConfig(self) -> org.optaplanner.core.config.solver.monitoring.MonitoringConfig: ...
    def getMoveThreadBufferSize(self) -> int: ...
    def getMoveThreadCount(self) -> str: ...
    def getPhaseConfigList(self) -> java.util.List[org.optaplanner.core.config.phase.PhaseConfig]: ...
    def getRandomFactoryClass(self) -> typing.Type[org.optaplanner.core.impl.solver.random.RandomFactory]: ...
    def getRandomSeed(self) -> int: ...
    def getRandomType(self) -> org.optaplanner.core.config.solver.random.RandomType: ...
    def getScoreDirectorFactoryConfig(self) -> org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig: ...
    def getSolutionClass(self) -> typing.Type[typing.Any]: ...
    def getTerminationConfig(self) -> org.optaplanner.core.config.solver.termination.TerminationConfig: ...
    def getThreadFactoryClass(self) -> typing.Type[java.util.concurrent.ThreadFactory]: ...
    def inherit(self, solverConfig: 'SolverConfig') -> 'SolverConfig': ...
    def offerRandomSeedFromSubSingleIndex(self, long: int) -> None: ...
    def setClassLoader(self, classLoader: java.lang.ClassLoader) -> None: ...
    def setDaemon(self, boolean: bool) -> None: ...
    def setDomainAccessType(self, domainAccessType: org.optaplanner.core.api.domain.common.DomainAccessType) -> None: ...
    def setEntityClassList(self, list: java.util.List[typing.Type[typing.Any]]) -> None: ...
    def setEnvironmentMode(self, environmentMode: EnvironmentMode) -> None: ...
    def setGizmoMemberAccessorMap(self, map: typing.Union[java.util.Map[str, org.optaplanner.core.impl.domain.common.accessor.MemberAccessor], typing.Mapping[str, org.optaplanner.core.impl.domain.common.accessor.MemberAccessor]]) -> None: ...
    def setGizmoSolutionClonerMap(self, map: typing.Union[java.util.Map[str, org.optaplanner.core.api.domain.solution.cloner.SolutionCloner], typing.Mapping[str, org.optaplanner.core.api.domain.solution.cloner.SolutionCloner]]) -> None: ...
    def setMonitoringConfig(self, monitoringConfig: org.optaplanner.core.config.solver.monitoring.MonitoringConfig) -> None: ...
    def setMoveThreadBufferSize(self, integer: int) -> None: ...
    def setMoveThreadCount(self, string: str) -> None: ...
    def setPhaseConfigList(self, list: java.util.List[org.optaplanner.core.config.phase.PhaseConfig]) -> None: ...
    def setRandomFactoryClass(self, class_: typing.Type[org.optaplanner.core.impl.solver.random.RandomFactory]) -> None: ...
    def setRandomSeed(self, long: int) -> None: ...
    def setRandomType(self, randomType: org.optaplanner.core.config.solver.random.RandomType) -> None: ...
    def setScoreDirectorFactoryConfig(self, scoreDirectorFactoryConfig: org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig) -> None: ...
    def setSolutionClass(self, class_: typing.Type[typing.Any]) -> None: ...
    def setTerminationConfig(self, terminationConfig: org.optaplanner.core.config.solver.termination.TerminationConfig) -> None: ...
    def setThreadFactoryClass(self, class_: typing.Type[java.util.concurrent.ThreadFactory]) -> None: ...
    def visitReferencedClasses(self, consumer: typing.Union[java.util.function.Consumer[typing.Type[typing.Any]], typing.Callable[[typing.Type[typing.Any]], None]]) -> None: ...
    def withConstraintProviderClass(self, class_: typing.Type[org.optaplanner.core.api.score.stream.ConstraintProvider]) -> 'SolverConfig': ...
    def withConstraintStreamImplType(self, constraintStreamImplType: org.optaplanner.core.api.score.stream.ConstraintStreamImplType) -> 'SolverConfig': ...
    def withDaemon(self, boolean: bool) -> 'SolverConfig': ...
    def withDomainAccessType(self, domainAccessType: org.optaplanner.core.api.domain.common.DomainAccessType) -> 'SolverConfig': ...
    def withEasyScoreCalculatorClass(self, class_: typing.Type[org.optaplanner.core.api.score.calculator.EasyScoreCalculator]) -> 'SolverConfig': ...
    def withEntityClassList(self, list: java.util.List[typing.Type[typing.Any]]) -> 'SolverConfig': ...
    def withEntityClasses(self, *class_: typing.Type[typing.Any]) -> 'SolverConfig': ...
    def withEnvironmentMode(self, environmentMode: EnvironmentMode) -> 'SolverConfig': ...
    def withGizmoMemberAccessorMap(self, map: typing.Union[java.util.Map[str, org.optaplanner.core.impl.domain.common.accessor.MemberAccessor], typing.Mapping[str, org.optaplanner.core.impl.domain.common.accessor.MemberAccessor]]) -> 'SolverConfig': ...
    def withGizmoSolutionClonerMap(self, map: typing.Union[java.util.Map[str, org.optaplanner.core.api.domain.solution.cloner.SolutionCloner], typing.Mapping[str, org.optaplanner.core.api.domain.solution.cloner.SolutionCloner]]) -> 'SolverConfig': ...
    def withMonitoringConfig(self, monitoringConfig: org.optaplanner.core.config.solver.monitoring.MonitoringConfig) -> 'SolverConfig': ...
    def withMoveThreadBufferSize(self, integer: int) -> 'SolverConfig': ...
    def withMoveThreadCount(self, string: str) -> 'SolverConfig': ...
    def withPhaseList(self, list: java.util.List[org.optaplanner.core.config.phase.PhaseConfig]) -> 'SolverConfig': ...
    def withPhases(self, *phaseConfig: org.optaplanner.core.config.phase.PhaseConfig) -> 'SolverConfig': ...
    def withRandomFactoryClass(self, class_: typing.Type[org.optaplanner.core.impl.solver.random.RandomFactory]) -> 'SolverConfig': ...
    def withRandomSeed(self, long: int) -> 'SolverConfig': ...
    def withRandomType(self, randomType: org.optaplanner.core.config.solver.random.RandomType) -> 'SolverConfig': ...
    def withScoreDirectorFactory(self, scoreDirectorFactoryConfig: org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig) -> 'SolverConfig': ...
    def withSolutionClass(self, class_: typing.Type[typing.Any]) -> 'SolverConfig': ...
    def withTerminationConfig(self, terminationConfig: org.optaplanner.core.config.solver.termination.TerminationConfig) -> 'SolverConfig': ...
    def withTerminationSpentLimit(self, duration: java.time.Duration) -> 'SolverConfig': ...
    def withThreadFactoryClass(self, class_: typing.Type[java.util.concurrent.ThreadFactory]) -> 'SolverConfig': ...

class SolverManagerConfig(org.optaplanner.core.config.AbstractConfig['SolverManagerConfig']):
    PARALLEL_SOLVER_COUNT_AUTO: typing.ClassVar[str] = ...
    def __init__(self): ...
    def copyConfig(self) -> 'SolverManagerConfig': ...
    def getParallelSolverCount(self) -> str: ...
    def getThreadFactoryClass(self) -> typing.Type[java.util.concurrent.ThreadFactory]: ...
    def inherit(self, solverManagerConfig: 'SolverManagerConfig') -> 'SolverManagerConfig': ...
    def resolveParallelSolverCount(self) -> int: ...
    def setParallelSolverCount(self, string: str) -> None: ...
    def setThreadFactoryClass(self, class_: typing.Type[java.util.concurrent.ThreadFactory]) -> None: ...
    def visitReferencedClasses(self, consumer: typing.Union[java.util.function.Consumer[typing.Type[typing.Any]], typing.Callable[[typing.Type[typing.Any]], None]]) -> None: ...
    def withParallelSolverCount(self, string: str) -> 'SolverManagerConfig': ...
    def withThreadFactoryClass(self, class_: typing.Type[java.util.concurrent.ThreadFactory]) -> 'SolverManagerConfig': ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.optaplanner.core.config.solver")``.

    EnvironmentMode: typing.Type[EnvironmentMode]
    SolverConfig: typing.Type[SolverConfig]
    SolverManagerConfig: typing.Type[SolverManagerConfig]
    monitoring: org.optaplanner.core.config.solver.monitoring.__module_protocol__
    random: org.optaplanner.core.config.solver.random.__module_protocol__
    termination: org.optaplanner.core.config.solver.termination.__module_protocol__
