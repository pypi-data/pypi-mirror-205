
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import decimal
import java.lang.annotation
import java.math
import java.time
import java.time.temporal
import java.util
import typing



_ValueRange__T = typing.TypeVar('_ValueRange__T')  # <T>
class ValueRange(typing.Generic[_ValueRange__T]):
    def contains(self, t: _ValueRange__T) -> bool: ...
    def createRandomIterator(self, random: java.util.Random) -> java.util.Iterator[_ValueRange__T]: ...
    def isEmpty(self) -> bool: ...

class ValueRangeFactory:
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def createBigDecimalValueRange(bigDecimal: typing.Union[java.math.BigDecimal, decimal.Decimal], bigDecimal2: typing.Union[java.math.BigDecimal, decimal.Decimal]) -> 'CountableValueRange'[java.math.BigDecimal]: ...
    @typing.overload
    @staticmethod
    def createBigDecimalValueRange(bigDecimal: typing.Union[java.math.BigDecimal, decimal.Decimal], bigDecimal2: typing.Union[java.math.BigDecimal, decimal.Decimal], bigDecimal3: typing.Union[java.math.BigDecimal, decimal.Decimal]) -> 'CountableValueRange'[java.math.BigDecimal]: ...
    @typing.overload
    @staticmethod
    def createBigIntegerValueRange(bigInteger: java.math.BigInteger, bigInteger2: java.math.BigInteger) -> 'CountableValueRange'[java.math.BigInteger]: ...
    @typing.overload
    @staticmethod
    def createBigIntegerValueRange(bigInteger: java.math.BigInteger, bigInteger2: java.math.BigInteger, bigInteger3: java.math.BigInteger) -> 'CountableValueRange'[java.math.BigInteger]: ...
    @staticmethod
    def createBooleanValueRange() -> 'CountableValueRange'[bool]: ...
    @staticmethod
    def createDoubleValueRange(double: float, double2: float) -> ValueRange[float]: ...
    @typing.overload
    @staticmethod
    def createIntValueRange(int: int, int2: int) -> 'CountableValueRange'[int]: ...
    @typing.overload
    @staticmethod
    def createIntValueRange(int: int, int2: int, int3: int) -> 'CountableValueRange'[int]: ...
    @staticmethod
    def createLocalDateTimeValueRange(localDateTime: java.time.LocalDateTime, localDateTime2: java.time.LocalDateTime, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'CountableValueRange'[java.time.LocalDateTime]: ...
    @staticmethod
    def createLocalDateValueRange(localDate: java.time.LocalDate, localDate2: java.time.LocalDate, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'CountableValueRange'[java.time.LocalDate]: ...
    @staticmethod
    def createLocalTimeValueRange(localTime: java.time.LocalTime, localTime2: java.time.LocalTime, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'CountableValueRange'[java.time.LocalTime]: ...
    @typing.overload
    @staticmethod
    def createLongValueRange(long: int, long2: int) -> 'CountableValueRange'[int]: ...
    @typing.overload
    @staticmethod
    def createLongValueRange(long: int, long2: int, long3: int) -> 'CountableValueRange'[int]: ...
    _createTemporalValueRange__Temporal_ = typing.TypeVar('_createTemporalValueRange__Temporal_', bound=java.time.temporal.Temporal)  # <Temporal_>
    @staticmethod
    def createTemporalValueRange(temporal_: _createTemporalValueRange__Temporal_, temporal_2: _createTemporalValueRange__Temporal_, long: int, temporalUnit: java.time.temporal.TemporalUnit) -> 'CountableValueRange'[_createTemporalValueRange__Temporal_]: ...

class ValueRangeProvider(java.lang.annotation.Annotation):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def id(self) -> str: ...
    def toString(self) -> str: ...

_CountableValueRange__T = typing.TypeVar('_CountableValueRange__T')  # <T>
class CountableValueRange(ValueRange[_CountableValueRange__T], typing.Generic[_CountableValueRange__T]):
    def createOriginalIterator(self) -> java.util.Iterator[_CountableValueRange__T]: ...
    def get(self, long: int) -> _CountableValueRange__T: ...
    def getSize(self) -> int: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.optaplanner.core.api.domain.valuerange")``.

    CountableValueRange: typing.Type[CountableValueRange]
    ValueRange: typing.Type[ValueRange]
    ValueRangeFactory: typing.Type[ValueRangeFactory]
    ValueRangeProvider: typing.Type[ValueRangeProvider]
