
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.time
import java.util
import java.util.concurrent
import java.util.function
import jpype.protocol
import org.optaplanner.core.api.score
import org.optaplanner.core.api.score.director
import org.optaplanner.core.api.solver.change
import org.optaplanner.core.api.solver.event
import org.optaplanner.core.config.solver
import typing



_ProblemFactChange__Solution_ = typing.TypeVar('_ProblemFactChange__Solution_')  # <Solution_>
class ProblemFactChange(typing.Generic[_ProblemFactChange__Solution_]):
    def doChange(self, scoreDirector: org.optaplanner.core.api.score.director.ScoreDirector[_ProblemFactChange__Solution_]) -> None: ...

_SolutionManager__Solution_ = typing.TypeVar('_SolutionManager__Solution_')  # <Solution_>
_SolutionManager__Score_ = typing.TypeVar('_SolutionManager__Score_', bound=org.optaplanner.core.api.score.Score)  # <Score_>
class SolutionManager(typing.Generic[_SolutionManager__Solution_, _SolutionManager__Score_]):
    _create_0__Solution_ = typing.TypeVar('_create_0__Solution_')  # <Solution_>
    _create_0__Score_ = typing.TypeVar('_create_0__Score_', bound=org.optaplanner.core.api.score.Score)  # <Score_>
    _create_1__Solution_ = typing.TypeVar('_create_1__Solution_')  # <Solution_>
    _create_1__Score_ = typing.TypeVar('_create_1__Score_', bound=org.optaplanner.core.api.score.Score)  # <Score_>
    _create_1__ProblemId_ = typing.TypeVar('_create_1__ProblemId_')  # <ProblemId_>
    @typing.overload
    @staticmethod
    def create(solverFactory: 'SolverFactory'[_create_0__Solution_]) -> 'SolutionManager'[_create_0__Solution_, _create_0__Score_]: ...
    @typing.overload
    @staticmethod
    def create(solverManager: 'SolverManager'[_create_1__Solution_, _create_1__ProblemId_]) -> 'SolutionManager'[_create_1__Solution_, _create_1__Score_]: ...
    @typing.overload
    def explain(self, solution_: _SolutionManager__Solution_, solutionUpdatePolicy: 'SolutionUpdatePolicy') -> org.optaplanner.core.api.score.ScoreExplanation[_SolutionManager__Solution_, _SolutionManager__Score_]: ...
    @typing.overload
    def explain(self, solution_: _SolutionManager__Solution_) -> org.optaplanner.core.api.score.ScoreExplanation[_SolutionManager__Solution_, _SolutionManager__Score_]: ...
    @typing.overload
    def update(self, solution_: _SolutionManager__Solution_, solutionUpdatePolicy: 'SolutionUpdatePolicy') -> _SolutionManager__Score_: ...
    @typing.overload
    def update(self, solution_: _SolutionManager__Solution_) -> _SolutionManager__Score_: ...

class SolutionUpdatePolicy(java.lang.Enum['SolutionUpdatePolicy']):
    UPDATE_ALL: typing.ClassVar['SolutionUpdatePolicy'] = ...
    UPDATE_SCORE_ONLY: typing.ClassVar['SolutionUpdatePolicy'] = ...
    UPDATE_SHADOW_VARIABLES_ONLY: typing.ClassVar['SolutionUpdatePolicy'] = ...
    NO_UPDATE: typing.ClassVar['SolutionUpdatePolicy'] = ...
    def isScoreUpdateEnabled(self) -> bool: ...
    def isShadowVariableUpdateEnabled(self) -> bool: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'SolutionUpdatePolicy': ...
    @staticmethod
    def values() -> typing.MutableSequence['SolutionUpdatePolicy']: ...

_Solver__Solution_ = typing.TypeVar('_Solver__Solution_')  # <Solution_>
class Solver(typing.Generic[_Solver__Solution_]):
    def addEventListener(self, solverEventListener: typing.Union[org.optaplanner.core.api.solver.event.SolverEventListener[_Solver__Solution_], typing.Callable[[org.optaplanner.core.api.solver.event.BestSolutionChangedEvent[typing.Any]], None]]) -> None: ...
    def addProblemChange(self, problemChange: typing.Union[org.optaplanner.core.api.solver.change.ProblemChange[_Solver__Solution_], typing.Callable[[_Solver__Solution_, org.optaplanner.core.api.solver.change.ProblemChangeDirector], None]]) -> None: ...
    def addProblemChanges(self, list: java.util.List[typing.Union[org.optaplanner.core.api.solver.change.ProblemChange[_Solver__Solution_], typing.Callable[[_Solver__Solution_, org.optaplanner.core.api.solver.change.ProblemChangeDirector], None]]]) -> None: ...
    def addProblemFactChange(self, problemFactChange: typing.Union[ProblemFactChange[_Solver__Solution_], typing.Callable[[org.optaplanner.core.api.score.director.ScoreDirector[typing.Any]], None]]) -> bool: ...
    def addProblemFactChanges(self, list: java.util.List[typing.Union[ProblemFactChange[_Solver__Solution_], typing.Callable[[org.optaplanner.core.api.score.director.ScoreDirector[typing.Any]], None]]]) -> bool: ...
    def isEveryProblemChangeProcessed(self) -> bool: ...
    def isEveryProblemFactChangeProcessed(self) -> bool: ...
    def isSolving(self) -> bool: ...
    def isTerminateEarly(self) -> bool: ...
    def removeEventListener(self, solverEventListener: typing.Union[org.optaplanner.core.api.solver.event.SolverEventListener[_Solver__Solution_], typing.Callable[[org.optaplanner.core.api.solver.event.BestSolutionChangedEvent[typing.Any]], None]]) -> None: ...
    def solve(self, solution_: _Solver__Solution_) -> _Solver__Solution_: ...
    def terminateEarly(self) -> bool: ...

_SolverFactory__Solution_ = typing.TypeVar('_SolverFactory__Solution_')  # <Solution_>
class SolverFactory(typing.Generic[_SolverFactory__Solution_]):
    def buildSolver(self) -> Solver[_SolverFactory__Solution_]: ...
    _create__Solution_ = typing.TypeVar('_create__Solution_')  # <Solution_>
    @staticmethod
    def create(solverConfig: org.optaplanner.core.config.solver.SolverConfig) -> 'SolverFactory'[_create__Solution_]: ...
    _createFromXmlFile_0__Solution_ = typing.TypeVar('_createFromXmlFile_0__Solution_')  # <Solution_>
    _createFromXmlFile_1__Solution_ = typing.TypeVar('_createFromXmlFile_1__Solution_')  # <Solution_>
    @typing.overload
    @staticmethod
    def createFromXmlFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> 'SolverFactory'[_createFromXmlFile_0__Solution_]: ...
    @typing.overload
    @staticmethod
    def createFromXmlFile(file: typing.Union[java.io.File, jpype.protocol.SupportsPath], classLoader: java.lang.ClassLoader) -> 'SolverFactory'[_createFromXmlFile_1__Solution_]: ...
    _createFromXmlResource_0__Solution_ = typing.TypeVar('_createFromXmlResource_0__Solution_')  # <Solution_>
    _createFromXmlResource_1__Solution_ = typing.TypeVar('_createFromXmlResource_1__Solution_')  # <Solution_>
    @typing.overload
    @staticmethod
    def createFromXmlResource(string: str) -> 'SolverFactory'[_createFromXmlResource_0__Solution_]: ...
    @typing.overload
    @staticmethod
    def createFromXmlResource(string: str, classLoader: java.lang.ClassLoader) -> 'SolverFactory'[_createFromXmlResource_1__Solution_]: ...

_SolverJob__Solution_ = typing.TypeVar('_SolverJob__Solution_')  # <Solution_>
_SolverJob__ProblemId_ = typing.TypeVar('_SolverJob__ProblemId_')  # <ProblemId_>
class SolverJob(typing.Generic[_SolverJob__Solution_, _SolverJob__ProblemId_]):
    def addProblemChange(self, problemChange: typing.Union[org.optaplanner.core.api.solver.change.ProblemChange[_SolverJob__Solution_], typing.Callable[[_SolverJob__Solution_, org.optaplanner.core.api.solver.change.ProblemChangeDirector], None]]) -> java.util.concurrent.CompletableFuture[None]: ...
    def getFinalBestSolution(self) -> _SolverJob__Solution_: ...
    def getProblemId(self) -> _SolverJob__ProblemId_: ...
    def getSolverStatus(self) -> 'SolverStatus': ...
    def getSolvingDuration(self) -> java.time.Duration: ...
    def isTerminatedEarly(self) -> bool: ...
    def terminateEarly(self) -> None: ...

_SolverManager__Solution_ = typing.TypeVar('_SolverManager__Solution_')  # <Solution_>
_SolverManager__ProblemId_ = typing.TypeVar('_SolverManager__ProblemId_')  # <ProblemId_>
class SolverManager(java.lang.AutoCloseable, typing.Generic[_SolverManager__Solution_, _SolverManager__ProblemId_]):
    def addProblemChange(self, problemId_: _SolverManager__ProblemId_, problemChange: typing.Union[org.optaplanner.core.api.solver.change.ProblemChange[_SolverManager__Solution_], typing.Callable[[_SolverManager__Solution_, org.optaplanner.core.api.solver.change.ProblemChangeDirector], None]]) -> java.util.concurrent.CompletableFuture[None]: ...
    def close(self) -> None: ...
    _create_0__Solution_ = typing.TypeVar('_create_0__Solution_')  # <Solution_>
    _create_0__ProblemId_ = typing.TypeVar('_create_0__ProblemId_')  # <ProblemId_>
    _create_1__Solution_ = typing.TypeVar('_create_1__Solution_')  # <Solution_>
    _create_1__ProblemId_ = typing.TypeVar('_create_1__ProblemId_')  # <ProblemId_>
    _create_2__Solution_ = typing.TypeVar('_create_2__Solution_')  # <Solution_>
    _create_2__ProblemId_ = typing.TypeVar('_create_2__ProblemId_')  # <ProblemId_>
    _create_3__Solution_ = typing.TypeVar('_create_3__Solution_')  # <Solution_>
    _create_3__ProblemId_ = typing.TypeVar('_create_3__ProblemId_')  # <ProblemId_>
    @typing.overload
    @staticmethod
    def create(solverFactory: SolverFactory[_create_0__Solution_]) -> 'SolverManager'[_create_0__Solution_, _create_0__ProblemId_]: ...
    @typing.overload
    @staticmethod
    def create(solverFactory: SolverFactory[_create_1__Solution_], solverManagerConfig: org.optaplanner.core.config.solver.SolverManagerConfig) -> 'SolverManager'[_create_1__Solution_, _create_1__ProblemId_]: ...
    @typing.overload
    @staticmethod
    def create(solverConfig: org.optaplanner.core.config.solver.SolverConfig) -> 'SolverManager'[_create_2__Solution_, _create_2__ProblemId_]: ...
    @typing.overload
    @staticmethod
    def create(solverConfig: org.optaplanner.core.config.solver.SolverConfig, solverManagerConfig: org.optaplanner.core.config.solver.SolverManagerConfig) -> 'SolverManager'[_create_3__Solution_, _create_3__ProblemId_]: ...
    def getSolverStatus(self, problemId_: _SolverManager__ProblemId_) -> 'SolverStatus': ...
    @typing.overload
    def solve(self, problemId_: _SolverManager__ProblemId_, function: typing.Union[java.util.function.Function[_SolverManager__ProblemId_, _SolverManager__Solution_], typing.Callable[[_SolverManager__ProblemId_], _SolverManager__Solution_]], consumer: typing.Union[java.util.function.Consumer[_SolverManager__Solution_], typing.Callable[[_SolverManager__Solution_], None]], biConsumer: typing.Union[java.util.function.BiConsumer[_SolverManager__ProblemId_, java.lang.Throwable], typing.Callable[[_SolverManager__ProblemId_, java.lang.Throwable], None]]) -> SolverJob[_SolverManager__Solution_, _SolverManager__ProblemId_]: ...
    @typing.overload
    def solve(self, problemId_: _SolverManager__ProblemId_, solution_: _SolverManager__Solution_) -> SolverJob[_SolverManager__Solution_, _SolverManager__ProblemId_]: ...
    @typing.overload
    def solve(self, problemId_: _SolverManager__ProblemId_, solution_: _SolverManager__Solution_, consumer: typing.Union[java.util.function.Consumer[_SolverManager__Solution_], typing.Callable[[_SolverManager__Solution_], None]]) -> SolverJob[_SolverManager__Solution_, _SolverManager__ProblemId_]: ...
    @typing.overload
    def solve(self, problemId_: _SolverManager__ProblemId_, solution_: _SolverManager__Solution_, consumer: typing.Union[java.util.function.Consumer[_SolverManager__Solution_], typing.Callable[[_SolverManager__Solution_], None]], biConsumer: typing.Union[java.util.function.BiConsumer[_SolverManager__ProblemId_, java.lang.Throwable], typing.Callable[[_SolverManager__ProblemId_, java.lang.Throwable], None]]) -> SolverJob[_SolverManager__Solution_, _SolverManager__ProblemId_]: ...
    @typing.overload
    def solve(self, problemId_: _SolverManager__ProblemId_, function: typing.Union[java.util.function.Function[_SolverManager__ProblemId_, _SolverManager__Solution_], typing.Callable[[_SolverManager__ProblemId_], _SolverManager__Solution_]], consumer: typing.Union[java.util.function.Consumer[_SolverManager__Solution_], typing.Callable[[_SolverManager__Solution_], None]]) -> SolverJob[_SolverManager__Solution_, _SolverManager__ProblemId_]: ...
    @typing.overload
    def solveAndListen(self, problemId_: _SolverManager__ProblemId_, function: typing.Union[java.util.function.Function[_SolverManager__ProblemId_, _SolverManager__Solution_], typing.Callable[[_SolverManager__ProblemId_], _SolverManager__Solution_]], consumer: typing.Union[java.util.function.Consumer[_SolverManager__Solution_], typing.Callable[[_SolverManager__Solution_], None]], consumer2: typing.Union[java.util.function.Consumer[_SolverManager__Solution_], typing.Callable[[_SolverManager__Solution_], None]], biConsumer: typing.Union[java.util.function.BiConsumer[_SolverManager__ProblemId_, java.lang.Throwable], typing.Callable[[_SolverManager__ProblemId_, java.lang.Throwable], None]]) -> SolverJob[_SolverManager__Solution_, _SolverManager__ProblemId_]: ...
    @typing.overload
    def solveAndListen(self, problemId_: _SolverManager__ProblemId_, function: typing.Union[java.util.function.Function[_SolverManager__ProblemId_, _SolverManager__Solution_], typing.Callable[[_SolverManager__ProblemId_], _SolverManager__Solution_]], consumer: typing.Union[java.util.function.Consumer[_SolverManager__Solution_], typing.Callable[[_SolverManager__Solution_], None]]) -> SolverJob[_SolverManager__Solution_, _SolverManager__ProblemId_]: ...
    @typing.overload
    def solveAndListen(self, problemId_: _SolverManager__ProblemId_, function: typing.Union[java.util.function.Function[_SolverManager__ProblemId_, _SolverManager__Solution_], typing.Callable[[_SolverManager__ProblemId_], _SolverManager__Solution_]], consumer: typing.Union[java.util.function.Consumer[_SolverManager__Solution_], typing.Callable[[_SolverManager__Solution_], None]], biConsumer: typing.Union[java.util.function.BiConsumer[_SolverManager__ProblemId_, java.lang.Throwable], typing.Callable[[_SolverManager__ProblemId_, java.lang.Throwable], None]]) -> SolverJob[_SolverManager__Solution_, _SolverManager__ProblemId_]: ...
    def terminateEarly(self, problemId_: _SolverManager__ProblemId_) -> None: ...

class SolverStatus(java.lang.Enum['SolverStatus']):
    SOLVING_SCHEDULED: typing.ClassVar['SolverStatus'] = ...
    SOLVING_ACTIVE: typing.ClassVar['SolverStatus'] = ...
    NOT_SOLVING: typing.ClassVar['SolverStatus'] = ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'SolverStatus': ...
    @staticmethod
    def values() -> typing.MutableSequence['SolverStatus']: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.optaplanner.core.api.solver")``.

    ProblemFactChange: typing.Type[ProblemFactChange]
    SolutionManager: typing.Type[SolutionManager]
    SolutionUpdatePolicy: typing.Type[SolutionUpdatePolicy]
    Solver: typing.Type[Solver]
    SolverFactory: typing.Type[SolverFactory]
    SolverJob: typing.Type[SolverJob]
    SolverManager: typing.Type[SolverManager]
    SolverStatus: typing.Type[SolverStatus]
    change: org.optaplanner.core.api.solver.change.__module_protocol__
    event: org.optaplanner.core.api.solver.event.__module_protocol__
