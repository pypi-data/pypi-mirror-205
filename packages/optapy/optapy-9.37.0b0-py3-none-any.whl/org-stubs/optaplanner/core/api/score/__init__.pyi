
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import org.optaplanner.core.api.score.buildin
import org.optaplanner.core.api.score.calculator
import org.optaplanner.core.api.score.constraint
import org.optaplanner.core.api.score.director
import org.optaplanner.core.api.score.holder
import org.optaplanner.core.api.score.stream
import org.optaplanner.core.api.solver
import typing



_Score__Score_ = typing.TypeVar('_Score__Score_', bound='Score')  # <Score_>
class Score(java.lang.Comparable[_Score__Score_], java.io.Serializable, typing.Generic[_Score__Score_]):
    def abs(self) -> _Score__Score_: ...
    def add(self, score_: _Score__Score_) -> _Score__Score_: ...
    def divide(self, double: float) -> _Score__Score_: ...
    def getInitScore(self) -> int: ...
    def initScore(self) -> int: ...
    def isFeasible(self) -> bool: ...
    def isSolutionInitialized(self) -> bool: ...
    def isZero(self) -> bool: ...
    def multiply(self, double: float) -> _Score__Score_: ...
    def negate(self) -> _Score__Score_: ...
    def power(self, double: float) -> _Score__Score_: ...
    def subtract(self, score_: _Score__Score_) -> _Score__Score_: ...
    def toLevelDoubles(self) -> typing.MutableSequence[float]: ...
    def toLevelNumbers(self) -> typing.MutableSequence[java.lang.Number]: ...
    def toShortString(self) -> str: ...
    def withInitScore(self, int: int) -> _Score__Score_: ...
    def zero(self) -> _Score__Score_: ...

_ScoreExplanation__Solution_ = typing.TypeVar('_ScoreExplanation__Solution_')  # <Solution_>
_ScoreExplanation__Score_ = typing.TypeVar('_ScoreExplanation__Score_', bound=Score)  # <Score_>
class ScoreExplanation(typing.Generic[_ScoreExplanation__Solution_, _ScoreExplanation__Score_]):
    def getConstraintMatchTotalMap(self) -> java.util.Map[str, org.optaplanner.core.api.score.constraint.ConstraintMatchTotal[_ScoreExplanation__Score_]]: ...
    def getIndictmentMap(self) -> java.util.Map[typing.Any, org.optaplanner.core.api.score.constraint.Indictment[_ScoreExplanation__Score_]]: ...
    _getJustificationList_1__ConstraintJustification_ = typing.TypeVar('_getJustificationList_1__ConstraintJustification_', bound=org.optaplanner.core.api.score.stream.ConstraintJustification)  # <ConstraintJustification_>
    @typing.overload
    def getJustificationList(self) -> java.util.List[org.optaplanner.core.api.score.stream.ConstraintJustification]: ...
    @typing.overload
    def getJustificationList(self, class_: typing.Type[_getJustificationList_1__ConstraintJustification_]) -> java.util.List[_getJustificationList_1__ConstraintJustification_]: ...
    def getScore(self) -> _ScoreExplanation__Score_: ...
    def getSolution(self) -> _ScoreExplanation__Solution_: ...
    def getSummary(self) -> str: ...

_ScoreManager__Solution_ = typing.TypeVar('_ScoreManager__Solution_')  # <Solution_>
_ScoreManager__Score_ = typing.TypeVar('_ScoreManager__Score_', bound=Score)  # <Score_>
class ScoreManager(typing.Generic[_ScoreManager__Solution_, _ScoreManager__Score_]):
    _create_0__Solution_ = typing.TypeVar('_create_0__Solution_')  # <Solution_>
    _create_0__Score_ = typing.TypeVar('_create_0__Score_', bound=Score)  # <Score_>
    _create_1__Solution_ = typing.TypeVar('_create_1__Solution_')  # <Solution_>
    _create_1__Score_ = typing.TypeVar('_create_1__Score_', bound=Score)  # <Score_>
    _create_1__ProblemId_ = typing.TypeVar('_create_1__ProblemId_')  # <ProblemId_>
    @typing.overload
    @staticmethod
    def create(solverFactory: org.optaplanner.core.api.solver.SolverFactory[_create_0__Solution_]) -> 'ScoreManager'[_create_0__Solution_, _create_0__Score_]: ...
    @typing.overload
    @staticmethod
    def create(solverManager: org.optaplanner.core.api.solver.SolverManager[_create_1__Solution_, _create_1__ProblemId_]) -> 'ScoreManager'[_create_1__Solution_, _create_1__Score_]: ...
    @typing.overload
    def explain(self, solution_: _ScoreManager__Solution_, solutionUpdatePolicy: org.optaplanner.core.api.solver.SolutionUpdatePolicy) -> ScoreExplanation[_ScoreManager__Solution_, _ScoreManager__Score_]: ...
    @typing.overload
    def explain(self, solution_: _ScoreManager__Solution_) -> ScoreExplanation[_ScoreManager__Solution_, _ScoreManager__Score_]: ...
    def explainScore(self, solution_: _ScoreManager__Solution_) -> ScoreExplanation[_ScoreManager__Solution_, _ScoreManager__Score_]: ...
    def getSummary(self, solution_: _ScoreManager__Solution_) -> str: ...
    @typing.overload
    def update(self, solution_: _ScoreManager__Solution_, solutionUpdatePolicy: org.optaplanner.core.api.solver.SolutionUpdatePolicy) -> _ScoreManager__Score_: ...
    @typing.overload
    def update(self, solution_: _ScoreManager__Solution_) -> _ScoreManager__Score_: ...
    def updateScore(self, solution_: _ScoreManager__Solution_) -> _ScoreManager__Score_: ...

_AbstractScore__Score_ = typing.TypeVar('_AbstractScore__Score_', bound='AbstractScore')  # <Score_>
class AbstractScore(Score[_AbstractScore__Score_], java.io.Serializable, typing.Generic[_AbstractScore__Score_]):
    def initScore(self) -> int: ...

_IBendableScore__Score_ = typing.TypeVar('_IBendableScore__Score_', bound='IBendableScore')  # <Score_>
class IBendableScore(Score[_IBendableScore__Score_], java.io.Serializable, typing.Generic[_IBendableScore__Score_]):
    def getHardLevelsSize(self) -> int: ...
    def getLevelsSize(self) -> int: ...
    def getSoftLevelsSize(self) -> int: ...
    def hardLevelsSize(self) -> int: ...
    def levelsSize(self) -> int: ...
    def softLevelsSize(self) -> int: ...

_AbstractBendableScore__Score_ = typing.TypeVar('_AbstractBendableScore__Score_', bound='AbstractBendableScore')  # <Score_>
class AbstractBendableScore(AbstractScore[_AbstractBendableScore__Score_], IBendableScore[_AbstractBendableScore__Score_], typing.Generic[_AbstractBendableScore__Score_]): ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("org.optaplanner.core.api.score")``.

    AbstractBendableScore: typing.Type[AbstractBendableScore]
    AbstractScore: typing.Type[AbstractScore]
    IBendableScore: typing.Type[IBendableScore]
    Score: typing.Type[Score]
    ScoreExplanation: typing.Type[ScoreExplanation]
    ScoreManager: typing.Type[ScoreManager]
    buildin: org.optaplanner.core.api.score.buildin.__module_protocol__
    calculator: org.optaplanner.core.api.score.calculator.__module_protocol__
    constraint: org.optaplanner.core.api.score.constraint.__module_protocol__
    director: org.optaplanner.core.api.score.director.__module_protocol__
    holder: org.optaplanner.core.api.score.holder.__module_protocol__
    stream: org.optaplanner.core.api.score.stream.__module_protocol__
