{"version":3,"sources":["MyComponent.tsx","index.tsx"],"names":["MyComponent","_StreamlitComponentBa","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","state","textToSpeak","props","isFocused","render","name","label","translation","theme","style","_objectSpread","display","WebkitBoxAlign","alignItems","WebkitBoxPack","justifyContent","fontWeight","fontSize","borderRadius","borderWidth","borderStyle","borderColor","primaryColor","marginTop","marginLeft","lineHeight","color","width","height","WebkitUserSelect","backgroundColor","_jsx","children","_jsxs","flex","fontStyle","onClick","onClicked","disabled","onFocus","_onFocus","onBlur","_onBlur","margin","msg","window","SpeechSynthesisUtterance","monica","speechSynthesis","getVoices","filter","voice","voiceURI","text","rate","speak","setState","_createClass","StreamlitComponentBase","withStreamlitConnection","ReactDOM","React","StrictMode","document","getElementById"],"mappings":"uNAgBMA,EAAW,SAAAC,GAAAC,YAAAF,EAAAC,GAAA,IAAAE,EAAAC,YAAAJ,GAAA,SAAAA,IAAA,IAAAK,EAAAC,YAAA,KAAAN,GAAA,QAAAO,EAAAC,UAAAC,OAAAC,EAAA,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAAF,EAAAE,GAAAJ,UAAAI,GA6Gd,OA7GcP,EAAAF,EAAAU,KAAAC,MAAAX,EAAA,OAAAY,OAAAL,KACRM,MAAQ,CAAEC,YAAaZ,EAAKa,MAAMR,KAAW,KAAGS,WAAW,GAAOd,EAElEe,OAAS,WAGd,IAAMC,EAAOhB,EAAKa,MAAMR,KAAW,KAC7BY,EAAQjB,EAAKa,MAAMR,KAAY,OAAK,MACpCa,EAAclB,EAAKa,MAAMR,KAAkB,YAKzCc,EAAUnB,EAAKa,MAAfM,MACJC,EAA6B,CAAC,EAsClC,OAlCID,IAIFC,EAAKC,wBAAA,GACAD,GAAK,IACRE,QAAS,cACTC,eAAgB,SAChBC,WAAY,SACZC,cAAe,SACfC,eAAgB,SAChBC,WAAY,IACZC,SAAU,OACVC,aAAc,UACdC,YAAa,MACbC,YAAa,QACbC,YAAahC,EAAKW,MAAMG,UAAYK,EAAMc,aAAe,wBACzDC,UAAW,EACXC,WAAY,MACZC,WAAY,IACZC,MAAO,UACPC,MAAO,OACPC,OAAQ,OACRC,iBAAkB,OAClBC,gBAAiB,wBAWnBC,cAAA,OAAAC,SACEC,eAAA,OAAKxB,MAAO,CAACE,QAAS,QAAQqB,SAAA,CAC5BD,cAAA,OAAKtB,MAAO,CAACkB,MAAO,QAAQK,SAC1BD,cAAA,KAAAC,SACED,cAAA,QAAMtB,MAAO,CAACO,WAAY,QAAQgB,SAAE1B,QAGxC2B,eAAA,OAAKxB,MAAO,CAACyB,KAAM,KAAKF,SAAA,CACtBD,cAAA,KAAAC,SAAI3B,IACJ0B,cAAA,KAAGtB,MAAO,CAAC0B,UAAW,UAAUH,SAAEzB,OAEpCwB,cAAA,OAAKtB,MAAO,CAACkB,MAAO,QAAQK,SAC1BD,cAAA,UACItB,MAAOA,EACP2B,QAAS/C,EAAKgD,UACdC,SAAUjD,EAAKa,MAAMoC,SACrBC,QAASlD,EAAKmD,SACdC,OAAQpD,EAAKqD,QAAQV,SAEvBD,cAAA,KAAGtB,MAAO,CAAEkC,OAAQ,GAAGX,SAAC,yBAOpC,EAEA3C,EACQgD,UAAY,WAGMhD,EAAKW,MAArBC,YAAR,IACM2C,EAAM,IAAIC,OAAOC,yBACjBC,EAASF,OAAOG,gBAAgBC,YAAYC,QAChD,SAACC,GAAK,MAAwB,yCAAnBA,EAAMC,QAAmD,IAAE,GACxER,EAAIS,KAAOhE,EAAKa,MAAMR,KAAW,KACjCkD,EAAIO,MAAQJ,EAEZH,EAAIU,KAAO,GACXT,OAAOG,gBAAgBO,MAAMX,EAM/B,EAEAvD,EACQmD,SAAW,WACjBnD,EAAKmE,SAAS,CAAErD,WAAW,GAC7B,EAEAd,EACQqD,QAAU,WAChBrD,EAAKmE,SAAS,CAAErD,WAAW,GAC7B,EAACd,CAAA,QAAAoE,YAAAzE,EAAA,CA7Gc,CAAS0E,KAqHXC,cAAwB3E,GCjIvC4E,IAASxD,OACP2B,cAAC8B,IAAMC,WAAU,CAAA9B,SACfD,cAAC/C,EAAW,MAEd+E,SAASC,eAAe,Q","file":"static/js/main.78d08be9.chunk.js","sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\n\ninterface State {\n  textToSpeak: string;\n  isFocused: boolean;\n}\n\n/**\n * This is a React-based component template. The `render()` function is called\n * automatically when your component should be re-rendered.\n */\nclass MyComponent extends StreamlitComponentBase<State> {\n  public state = { textToSpeak: this.props.args[\"name\"], isFocused: false }\n\n  public render = (): ReactNode => {\n    // Arguments that are passed to the plugin in Python are accessible\n    // via `this.props.args`. Here, we access the \"name\" arg.\n    const name = this.props.args[\"name\"]\n    const label = this.props.args[\"label\"] || 'AI:'\n    const translation = this.props.args[\"translation\"]\n\n    // Streamlit sends us a theme object via props that we can use to ensure\n    // that our component has visuals that match the active theme in a\n    // streamlit app.\n    const { theme } = this.props\n    let style: React.CSSProperties = {}\n\n    // Maintain compatibility with older versions of Streamlit that don't send\n    // a theme object.\n    if (theme) {\n      // Use the theme object to style our button border. Alternatively, the\n      // theme style is defined in CSS vars.\n\n      style = {\n        ...style,\n        display: \"inline-flex\",\n        WebkitBoxAlign: \"center\",\n        alignItems: \"center\",\n        WebkitBoxPack: \"center\",\n        justifyContent: \"center\",\n        fontWeight: 400,\n        fontSize: \"15px\",\n        borderRadius: \"0.25rem\",\n        borderWidth: \"1px\",\n        borderStyle: \"solid\",\n        borderColor: this.state.isFocused ? theme.primaryColor : \"rgba(49, 51, 63, 0.2)\",\n        marginTop: 0,\n        marginLeft: \"5px\",\n        lineHeight: 1.6,\n        color: \"inherit\",\n        width: \"auto\",\n        height: \"40px\",\n        WebkitUserSelect: \"none\",\n        backgroundColor: \"rgb(255, 255, 255)\",\n      }\n\n\n    }\n\n    // Show a button and some text.\n    // When the button is clicked, we'll increment our \"numClicks\" state\n    // variable, and send its new value back to Streamlit, where it'll\n    // be available to the Python program.\n    return (\n      <div>\n        <div style={{display: 'flex'}}>\n          <div style={{width: '35px'}}>\n            <p>\n              <span style={{fontWeight: 'bold'}}>{label}</span>\n            </p>\n          </div>\n          <div style={{flex: '1'}}>\n            <p>{name}</p>\n            <p style={{fontStyle: 'italic'}}>{translation}</p>\n          </div>\n          <div style={{width: '45px'}}>\n            <button\n                style={style}\n                onClick={this.onClicked}\n                disabled={this.props.disabled}\n                onFocus={this._onFocus}\n                onBlur={this._onBlur}\n              >\n              <p style={{ margin: 0}}>ðŸ—£</p>\n            </button>\n          </div>\n\n        </div>\n      </div>\n    )\n  }\n\n  /** Click handler for our \"Click Me!\" button. */\n  private onClicked = (): void => {\n    // Increment state.numClicks, and pass the new value back to\n    // Streamlit via `Streamlit.setComponentValue`.\n    const { textToSpeak } = this.state;\n    const msg = new window.SpeechSynthesisUtterance();\n    const monica = window.speechSynthesis.getVoices().filter(\n      (voice) => voice.voiceURI === 'com.apple.voice.compact.es-ES.Monica')[0];\n    msg.text = this.props.args[\"name\"];\n    msg.voice = monica;\n    // Slower speech rate is easier for learning\n    msg.rate = 0.8;\n    window.speechSynthesis.speak(msg);\n\n//     this.setState(\n//       prevState => ({ textToSpeak: prevState.textToSpeak }),\n//       () => Streamlit.setComponentValue(textToSpeak)\n//     )\n  }\n\n  /** Focus handler for our \"Click Me!\" button. */\n  private _onFocus = (): void => {\n    this.setState({ isFocused: true })\n  }\n\n  /** Blur handler for our \"Click Me!\" button. */\n  private _onBlur = (): void => {\n    this.setState({ isFocused: false })\n  }\n}\n\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(MyComponent)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport MyComponent from \"./MyComponent\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <MyComponent />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}