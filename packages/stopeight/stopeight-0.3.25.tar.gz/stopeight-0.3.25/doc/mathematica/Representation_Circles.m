(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["Representation`"];*)


(* ::Input:: *)
(*Clear["Representation`*"];Needs["Spline`"];*)


(* ::Input:: *)
(*Representation::usage="The left and right on-curve control points at quadratic end points based on the middle quadratic endpoint of the quartic Jordanian form as seen from the intersection of the half angle in the middle with the base line";*)
(*InverseRepresentation::usage="The inverse of the representation, taking the left on-curve control point, the half-angle point on the base line and the right on-curve control point";*)
(*arc::usage = "The points of a Stopeight Analyzer quartic spline representation";*)


(* ::Input:: *)
(*Begin["Representation`Private`"];*)


(* ::Input:: *)
(*Representation[s_,b2_,e_]:=Module[{*)
(*},*)
(*WHAngle=Pi+CornerAngle[s,b2,e]/2;*)
(*tangentAngle=WHAngle-Pi/2;*)
(*WH={{Cos[WHAngle],-Sin[WHAngle]},{Sin[WHAngle],Cos[WHAngle]}}.{b2[[1]]-s[[1]],b2[[2]]-s[[2]]}+{b2[[1]],b2[[2]]};*)
(*Tangent ={{Cos[tangentAngle],-Sin[tangentAngle]},{Sin[tangentAngle],Cos[tangentAngle]}}.{b2[[1]]-s[[1]],b2[[2]]-s[[2]]}+{b2[[1]],b2[[2]]};*)
(*m=((b2[[2]]-Tangent[[2]])/(b2[[1]]-Tangent[[1]]));*)
(*T1=Tangent[[2]]==m*Tangent[[1]]+offset;*)
(*T2=b2[[2]]==m*b2[[1]]+offset;*)
(*WHT=IntersectVectors[b2,WH,s,e];*)
(*stretchS=2*(s-e)+e;*)
(*stretchE=2*(e-s)+s;*)
(*lengthL=(s[[1]]-e[[1]])^2+(s[[2]]-e[[2]])^2==(tlx-e[[1]])^2+(tly-e[[2]])^2;*)
(*lengthR=(e[[1]]-s[[1]])^2+(e[[2]]-s[[2]])^2==(trx-s[[1]])^2+(try-s[[2]])^2;*)
(*onTangentL=tly==m*tlx+offset;*)
(*onTangentR=try==m*trx+offset;*)
(*angleL=PlanarAngle[{s,{tlx,tly},stretchE}]==Pi/2;*)
(*angleR=PlanarAngle[{e,{trx,try},stretchS}]==Pi/2;*)
(*angleC=PlanarAngle[{s,b2,e}]>=Pi/2;*)
(*sol=Solve[angleL&&angleR&&angleC&&onTangentL&&onTangentR&&lengthL&&lengthR&&T1&&T2,{tlx,tly,trx,try,offset}];*)
(*lengthSTLandETR=Function[(#1[[1]][[2]]-s[[1]])^2+(#1[[2]][[2]]-s[[2]])^2<= (b2[[1]]-s[[1]])^2+(b2[[2]]-s[[2]])^2 &&(#1[[3]][[2]]-e[[1]])^2+(#1[[4]][[2]]-e[[2]])^2<= (b2[[1]]-e[[1]])^2+(b2[[2]]-e[[2]])^2 ];*)
(*sol=Cases[sol,_?lengthSTLandETR,{1}][[1]];*)
(*TL={sol[[1]][[2]],sol[[2]][[2]]};*)
(*TR={sol[[3]][[2]],sol[[4]][[2]]};*)
(*b1=IntersectVectors[s,b2,WHT,TL];*)
(*b3=IntersectVectors[e,b2,WHT,TR];*)
(*b1=(b1-WHT)*Sqrt[2]+WHT;*)
(*b3=(b3-WHT)*Sqrt[2]+WHT;*)
(*{b1,WHT,b3}*)
(*]*)
(*InverseRepresentation[b1_,WHT_,b3_]:=Module[{*)
(*},*)
(*interL=b1;*)
(*interR=b3;*)
(*interL=(interL-WHT)/Sqrt[2]+WHT;*)
(*interR=(interR-WHT)/Sqrt[2]+WHT;*)
(*angleL=2*CornerAngle[WHT,interL,interR];*)
(*angleR=2*CornerAngle[WHT,interR,interL];*)
(*upperL={{Cos[angleL],-Sin[angleL]},{Sin[angleL],Cos[angleL]}}.{WHT[[1]]-interL[[1]],WHT[[2]]-interL[[2]]}+{interL[[1]],interL[[2]]};*)
(*upperR={{Cos[angleR],-Sin[angleR]},{Sin[angleR],Cos[angleR]}}.{WHT[[1]]-interR[[1]],WHT[[2]]-interR[[2]]}+{interR[[1]],interR[[2]]};*)
(*c2=IntersectVectors[b1,upperL,b3,upperR];*)
(*Tangent ={{Cos[-Pi/2],-Sin[-Pi/2]},{Sin[-Pi/2],Cos[-Pi/2]}}.{WHT[[1]]-c2[[1]],WHT[[2]]-c2[[2]]}+{c2[[1]],c2[[2]]};*)
(*TL=IntersectVectors[WHT,b1,c2,Tangent];*)
(*TR=IntersectVectors[WHT,b3,c2,Tangent];*)
(*lowerL1=c2[[2]] == mL*c2[[1]]+oL;*)
(*lowerL2 = interL[[2]] == mL*interL[[1]]+oL;*)
(*solL=Solve[lowerL1&&lowerL2,{mL,oL}];*)
(*onLowerL=Sy == solL[[1]][[1]][[2]]*Sx+solL[[1]][[2]][[2]];*)
(*lowerR1=c2[[2]] == mR*c2[[1]]+oR;*)
(*lowerR2 = interR[[2]] == mR*interR[[1]]+oR;*)
(*solR = Solve[lowerR1&&lowerR2,{mR,oR}];*)
(*onLowerR=Ey == solR[[1]][[1]][[2]]*Ex+solR[[1]][[2]][[2]];*)
(*GS1=WHT[[2]] == inclination*WHT[[1]]+offset;*)
(*GS2=Sy==inclination*Sx+offset;*)
(*GS3=Ey == inclination*Ex+offset;*)
(*CircleL={Ex,Ey}\[Element]Circle[TL,Radius];*)
(*CircleR={Sx,Sy}\[Element]Circle[TR,Radius];*)
(*CircleWHT1={Sx,Sy}\[Element]Circle[{Cx,Cy},Radius];*)
(*CircleWHT2={Ex,Ey}\[Element]Circle[{Cx,Cy},Radius];*)
(*(*SE=EuclideanDistance[{Sx,Sy},{Ex,Ey}] == Radius;*)*)
(*sol=Solve[onLowerL&&onLowerR&&GS1&&GS2&&GS3&&CircleL&&CircleR&&CircleWHT1&&CircleWHT2,{inclination,offset,Sx,Sy,Ex,Ey,Cx,Cy,Radius}];*)
(*s={sol[[4]][[3]][[2]],sol[[4]][[4]][[2]]};*)
(*e={sol[[4]][[5]][[2]],sol[[4]][[6]][[2]]};*)
(*{{s,e},{s,c2},{e,c2}}*)
(*]*)
(*arc[s_,c2_,e_]:=Module[{},*)
(*sol = H4[pascalMatrix[5],IdentityMatrix[5],s,Representation[s,c2,e][[1]],c2,Representation[s,c2,e][[3]],e]; Table[{p=Flatten[{{1,t,t^2,t^3,t^4}}.pascalMatrix[5].sol];*)
(*p[[1]],*)
(*p[[2]]*)
(*},{t,0,1,1/8}]*)
(*]*)


(* ::Input:: *)
(*End[];*)
(*EndPackage[];*)
