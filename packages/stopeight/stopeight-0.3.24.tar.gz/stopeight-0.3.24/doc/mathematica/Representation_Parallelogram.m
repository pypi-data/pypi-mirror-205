(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["Representation`"];*)


(* ::Input:: *)
(*Clear["Representation`*"];Needs["Spline`"];*)


(* ::Input:: *)
(*Representation::usage="The left and right on-curve control points at quadratic end points based on the middle quadratic endpoint of the quartic Jordanian form as seen from the intersection of the half angle in the middle with the base line";*)
(*InverseRepresentation::usage="The reverse of the representation, taking the left on-curve control point, the half-angle point on the base line and the right on-curve control point";*)
(*arc::usage = "The points of a Stopeight Analyzer quartic spline representation";*)


(* ::Input:: *)
(*Begin["Representation`Private`"];*)


(* ::Input:: *)
(*Representation[s_,b2_,e_]:=Module[{*)
(*},*)
(*WHAngle=Pi+CornerAngle[s,b2,e]/2;*)
(*tangentAngle=WHAngle-Pi/2;*)
(*WH={{Cos[WHAngle],-Sin[WHAngle]},{Sin[WHAngle],Cos[WHAngle]}}.{b2[[1]]-s[[1]],b2[[2]]-s[[2]]}+{b2[[1]],b2[[2]]};*)
(*Tangent ={{Cos[tangentAngle],-Sin[tangentAngle]},{Sin[tangentAngle],Cos[tangentAngle]}}.{b2[[1]]-s[[1]],b2[[2]]-s[[2]]}+{b2[[1]],b2[[2]]};*)
(*WHT=IntersectVectors[b2,WH,s,e];*)
(*TL=IntersectVectors[s,Flatten[WH-WHT]+{s[[1]],s[[2]]},b2,Tangent];*)
(*TR=IntersectVectors[e,Flatten[WH-WHT]+{e[[1]],e[[2]]},b2,Tangent];*)
(*b1=IntersectVectors[s,b2,WHT,TL];*)
(*b3=IntersectVectors[e,b2,WHT,TR];*)
(*b1=(b1-WHT)*Sqrt[2]+WHT;*)
(*b3=(b3-WHT)*Sqrt[2]+WHT;*)
(*{b1,WHT,b3}*)
(*]*)
(*InverseRepresentation[b1_,WHT_,b3_]:=Module[{*)
(*},*)
(*interL=b1;*)
(*interR=b3;*)
(*interL=(interL-WHT)/Sqrt[2]+WHT;*)
(*interR=(interR-WHT)/Sqrt[2]+WHT;*)
(*(*upperL=interL+(b3-WHT);*)
(*upperR=interR+(b1-WHT);*)*)
(*angleL=2*CornerAngle[WHT,interL,interR];*)
(*angleR=2*CornerAngle[WHT,interR,interL];*)
(*upperL={{Cos[angleL],-Sin[angleL]},{Sin[angleL],Cos[angleL]}}.{WHT[[1]]-interL[[1]],WHT[[2]]-interL[[2]]}+{interL[[1]],interL[[2]]};*)
(*upperR={{Cos[angleR],-Sin[angleR]},{Sin[angleR],Cos[angleR]}}.{WHT[[1]]-interR[[1]],WHT[[2]]-interR[[2]]}+{interR[[1]],interR[[2]]};*)
(*c2=IntersectVectors[interL,upperL,interR,upperR];*)
(*(*c2=(c2-WHT)*Sqrt[2]+WHT;*)*)
(*Tangent ={{Cos[-Pi/2],-Sin[-Pi/2]},{Sin[-Pi/2],Cos[-Pi/2]}}.{c2[[1]]-WHT[[1]],c2[[2]]-WHT[[2]]}+{c2[[1]],c2[[2]]};*)
(*TL=IntersectVectors[WHT,b1,c2,Tangent];*)
(*TR=IntersectVectors[WHT,b3,c2,Tangent];*)
(*WHL=TL+(WHT-c2);*)
(*WHR=TR+(WHT-c2);*)
(*s=IntersectVectors[TL,WHL,c2,interL];*)
(*e=IntersectVectors[TR,WHR,c2,interR];*)
(*(*{{WHT,c2},{WHT,interL},{WHT,interR},{interL,upperL},{interR,upperR}}*)*)
(*(*{{WHT,c2},{c2,Tangent},{c2,c2-(Tangent-c2)}}*)*)
(*{s,c2,e}*)
(*]*)
(*arc[s_,c2_,e_]:=Module[{},*)
(*sol = H4[pascalMatrix[5],IdentityMatrix[5],s,Representation[s,c2,e][[1]],c2,Representation[s,c2,e][[3]],e]; Table[{p=Flatten[{{1,t,t^2,t^3,t^4}}.pascalMatrix[5].sol];*)
(*p[[1]],*)
(*p[[2]]*)
(*},{t,0,1,1/8}]*)
(*]*)


(* ::Input:: *)
(*End[];*)
(*EndPackage[];*)
