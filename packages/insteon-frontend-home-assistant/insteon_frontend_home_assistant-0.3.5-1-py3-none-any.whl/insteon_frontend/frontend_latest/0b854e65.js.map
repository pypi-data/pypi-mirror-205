{"version":3,"file":"0b854e65.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsEA;AAIA;;AAKA;;;;;;ACzDA;;;;AAKA;;;;;;;;;;;;;;;;;;;;ACkBA;ACJA;;AAEA;AACA;;;AAkLA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAhBA;;ACzKA;;AAGA;AACA;AACA;;AAEA;AAGA;;AAEA;;;AAGA;;AAGA;AACA;;;;AAIA;;;AAGA;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FA;;AC3JA;;;;AAOA;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4FA;;AC4DA;AACA;AACA;AACA;AACA;;;;;AAKA;;;;;AAKA;AAvMA;;;;AA4MA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;;;;AAKA;AACA;;;AAGA;;AAIA;AACA;;;;;AAMA;;;;;AAMA;;AAEA;AACA;AACA;;AAnPA;;;AAyPA;AAuBA;;;;;AAKA;AACA;AACA;AACA;;;;;AAKA;;AAEA;;;AAGA;;;AAGA;;;AAKA;;AAEA;AACA;AAGA;AACA;;;AAGA;;;AAOA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAvBA;;;;;;AAkCA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmfA","sources":["webpack://insteon-panel-frontend/./homeassistant-frontend/src/components/ha-card.ts","webpack://insteon-panel-frontend/./homeassistant-frontend/src/components/ha-fab.ts","webpack://insteon-panel-frontend/./homeassistant-frontend/src/components/ha-switch.ts","webpack://insteon-panel-frontend/./src/device/insteon-device-picker.ts","webpack://insteon-panel-frontend/./homeassistant-frontend/src/layouts/hass-subpage.ts","webpack://insteon-panel-frontend/./homeassistant-frontend/src/panels/config/ha-config-section.ts","webpack://insteon-panel-frontend/./src/scene/insteon-scene-editor.ts"],"sourcesContent":["import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\n\n@customElement(\"ha-card\")\nexport class HaCard extends LitElement {\n  @property() public header?: string;\n\n  @property({ type: Boolean, reflect: true }) public raised = false;\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        background: var(\n          --ha-card-background,\n          var(--card-background-color, white)\n        );\n        box-shadow: var(--ha-card-box-shadow, none);\n        box-sizing: border-box;\n        border-radius: var(--ha-card-border-radius, 12px);\n        border-width: var(--ha-card-border-width, 1px);\n        border-style: solid;\n        border-color: var(\n          --ha-card-border-color,\n          var(--divider-color, #e0e0e0)\n        );\n        color: var(--primary-text-color);\n        display: block;\n        transition: all 0.3s ease-out;\n        position: relative;\n      }\n\n      :host([raised]) {\n        border: none;\n        box-shadow: var(\n          --ha-card-box-shadow,\n          0px 2px 1px -1px rgba(0, 0, 0, 0.2),\n          0px 1px 1px 0px rgba(0, 0, 0, 0.14),\n          0px 1px 3px 0px rgba(0, 0, 0, 0.12)\n        );\n      }\n\n      .card-header,\n      :host ::slotted(.card-header) {\n        color: var(--ha-card-header-color, --primary-text-color);\n        font-family: var(--ha-card-header-font-family, inherit);\n        font-size: var(--ha-card-header-font-size, 24px);\n        letter-spacing: -0.012em;\n        line-height: 48px;\n        padding: 12px 16px 16px;\n        display: block;\n        margin-block-start: 0px;\n        margin-block-end: 0px;\n        font-weight: normal;\n      }\n\n      :host ::slotted(.card-content:not(:first-child)),\n      slot:not(:first-child)::slotted(.card-content) {\n        padding-top: 0px;\n        margin-top: -8px;\n      }\n\n      :host ::slotted(.card-content) {\n        padding: 16px;\n      }\n\n      :host ::slotted(.card-actions) {\n        border-top: 1px solid var(--divider-color, #e8e8e8);\n        padding: 5px 16px;\n      }\n    `;\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      ${this.header\n        ? html`<h1 class=\"card-header\">${this.header}</h1>`\n        : html``}\n      <slot></slot>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-card\": HaCard;\n  }\n}\n","import { FabBase } from \"@material/mwc-fab/mwc-fab-base\";\nimport { styles } from \"@material/mwc-fab/mwc-fab.css\";\nimport { customElement } from \"lit/decorators\";\nimport { css } from \"lit\";\n\n@customElement(\"ha-fab\")\nexport class HaFab extends FabBase {\n  protected firstUpdated(changedProperties) {\n    super.firstUpdated(changedProperties);\n    this.style.setProperty(\"--mdc-theme-secondary\", \"var(--primary-color)\");\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host .mdc-fab--extended .mdc-fab__icon {\n        margin-inline-start: -8px;\n        margin-inline-end: 12px;\n        direction: var(--direction);\n      }\n    `,\n    // safari workaround - must be explicit\n    document.dir === \"rtl\"\n      ? css`\n          :host .mdc-fab--extended .mdc-fab__icon {\n            direction: rtl;\n          }\n        `\n      : css``,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-fab\": HaFab;\n  }\n}\n","import { SwitchBase } from \"@material/mwc-switch/deprecated/mwc-switch-base\";\nimport { styles } from \"@material/mwc-switch/deprecated/mwc-switch.css\";\nimport { css } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { forwardHaptic } from \"../data/haptics\";\n\n@customElement(\"ha-switch\")\nexport class HaSwitch extends SwitchBase {\n  // Generate a haptic vibration.\n  // Only set to true if the new value of the switch is applied right away when toggling.\n  // Do not add haptic when a user is required to press save.\n  @property({ type: Boolean }) public haptic = false;\n\n  protected firstUpdated() {\n    super.firstUpdated();\n    this.addEventListener(\"change\", () => {\n      if (this.haptic) {\n        forwardHaptic(\"light\");\n      }\n    });\n  }\n\n  static override styles = [\n    styles,\n    css`\n      :host {\n        --mdc-theme-secondary: var(--switch-checked-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__thumb {\n        background-color: var(--switch-checked-button-color);\n        border-color: var(--switch-checked-button-color);\n      }\n      .mdc-switch.mdc-switch--checked .mdc-switch__track {\n        background-color: var(--switch-checked-track-color);\n        border-color: var(--switch-checked-track-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__thumb {\n        background-color: var(--switch-unchecked-button-color);\n        border-color: var(--switch-unchecked-button-color);\n      }\n      .mdc-switch:not(.mdc-switch--checked) .mdc-switch__track {\n        background-color: var(--switch-unchecked-track-color);\n        border-color: var(--switch-unchecked-track-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-switch\": HaSwitch;\n  }\n}\n","import \"@material/mwc-list/mwc-list-item\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../homeassistant-frontend/src/common/dom/fire_event\";\nimport { stringCompare } from \"../../homeassistant-frontend/src/common/string/compare\";\nimport {\n  AreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../../homeassistant-frontend/src/data/area_registry\";\nimport {\n  computeDeviceName,\n  DeviceEntityLookup,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../homeassistant-frontend/src/data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../../homeassistant-frontend/src/data/entity_registry\";\nimport { SubscribeMixin } from \"../../homeassistant-frontend/src/mixins/subscribe-mixin\";\nimport { PolymerChangedEvent } from \"../../homeassistant-frontend/src/polymer-types\";\nimport { HomeAssistant } from \"../../homeassistant-frontend/src/types\";\nimport \"../../homeassistant-frontend/src/components/ha-combo-box\";\nimport type { HaComboBox } from \"../../homeassistant-frontend/src/components/ha-combo-box\";\nimport { Insteon } from \"../data/insteon\";\nimport { computeDomain } from \"../../homeassistant-frontend/src/common/entity/compute_domain\";\n\ninterface Device {\n  name: string;\n  area: string;\n  id: string;\n}\n\nexport type HaDevicePickerDeviceFilterFunc = (\n  device: DeviceRegistryEntry\n) => boolean;\n\nconst rowRenderer: ComboBoxLitRenderer<Device> = (item) => html`<mwc-list-item\n  .twoline=${!!item.area}\n>\n  <span>${item.name}</span>\n  <span slot=\"secondary\">${item.area}</span>\n</mwc-list-item>`;\n\n@customElement(\"insteon-device-picker\")\nexport class InsteonDevicePicker extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public insteon!: Insteon;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public devices?: DeviceRegistryEntry[];\n\n  @property() public areas?: AreaRegistryEntry[];\n\n  @property() public entities?: EntityRegistryEntry[];\n\n  @property({ type: Array, attribute: \"includedDomains\" })\n  public includedDomains?: string[];\n\n  @property({ type: Array, attribute: \"excludedDomains\" })\n  public excludedDomains?: string[];\n\n  /**\n   * Show the modem in the list of devices.\n   * @type {Array}\n   * @attr include-modem\n   */\n  @property({\n    type: Boolean,\n    attribute: \"exclude-modem\",\n  })\n  public excludeModem?: boolean = false;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _init = false;\n\n  private _getDevices = memoizeOne(\n    (\n      devices: DeviceRegistryEntry[],\n      areas: AreaRegistryEntry[],\n      entities: EntityRegistryEntry[]\n    ): Device[] => {\n      if (!devices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_devices\"),\n          },\n        ];\n      }\n\n      const deviceEntityLookup: DeviceEntityLookup = {};\n\n      const filtered_included_entities = entities.filter(\n        (entity) =>\n          !this.includedDomains ||\n          this.includedDomains.includes(computeDomain(entity.entity_id))\n      );\n\n      const filtered_entities = filtered_included_entities.filter(\n        (entity) =>\n          !this.excludedDomains ||\n          !this.excludedDomains.includes(computeDomain(entity.entity_id))\n      );\n\n      for (const entity of filtered_entities) {\n        if (!entity.device_id) {\n          continue;\n        }\n        if (!(entity.device_id in deviceEntityLookup)) {\n          deviceEntityLookup[entity.device_id] = [];\n        }\n        deviceEntityLookup[entity.device_id].push(entity);\n      }\n\n      const areaLookup: { [areaId: string]: AreaRegistryEntry } = {};\n      for (const area of areas) {\n        areaLookup[area.area_id] = area;\n      }\n\n      const outputDevices = devices\n        .filter((device) => deviceEntityLookup.hasOwnProperty(device.id))\n        .map((device) => ({\n          id: device.id,\n          name: computeDeviceName(\n            device,\n            this.hass,\n            deviceEntityLookup[device.id]\n          ),\n          area:\n            device.area_id && areaLookup[device.area_id]\n              ? areaLookup[device.area_id].name\n              : this.hass.localize(\"ui.components.device-picker.no_area\"),\n        }));\n      if (!outputDevices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_match\"),\n          },\n        ];\n      }\n      if (outputDevices.length === 1) {\n        return outputDevices;\n      }\n      return outputDevices.sort((a, b) =>\n        stringCompare(a.name || \"\", b.name || \"\")\n      );\n    }\n  );\n\n  public open() {\n    this.comboBox?.open();\n  }\n\n  public focus() {\n    this.comboBox?.focus();\n  }\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeDeviceRegistry(this.hass.connection!, (devices) => {\n        this.devices = devices.filter(\n          (device) =>\n            device.config_entries &&\n            device.config_entries.includes(\n              this.insteon.config_entry.entry_id\n            ) &&\n            (!this.excludeModem || !device.model?.includes(\"(0x03\"))\n        );\n      }),\n      subscribeAreaRegistry(this.hass.connection!, (areas) => {\n        this.areas = areas;\n      }),\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this.entities = entities.filter(\n          (entity) =>\n            entity.entity_category == null &&\n            entity.config_entry_id == this.insteon.config_entry.entry_id\n        );\n      }),\n    ];\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this.devices && this.areas && this.entities) ||\n      (changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      (this.comboBox as any).items = this._getDevices(\n        this.devices!,\n        this.areas!,\n        this.entities!\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.devices || !this.areas || !this.entities) {\n      return html``;\n    }\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.device-picker.device\")\n          : this.label}\n        .value=${this._value}\n        .helper=${this.helper}\n        .renderer=${rowRenderer}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        item-value-path=\"id\"\n        item-label-path=\"name\"\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._deviceChanged}\n      ></ha-combo-box>\n    `;\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _deviceChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_devices\") {\n      newValue = \"\";\n    }\n\n    if (newValue !== this._value) {\n      this._setValue(newValue);\n    }\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"insteon-device-picker\": InsteonDevicePicker;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, eventOptions, property } from \"lit/decorators\";\nimport { restoreScroll } from \"../common/decorators/restore-scroll\";\nimport { toggleAttribute } from \"../common/dom/toggle_attribute\";\nimport { computeRTL } from \"../common/util/compute_rtl\";\nimport \"../components/ha-icon-button-arrow-prev\";\nimport \"../components/ha-menu-button\";\nimport { HomeAssistant } from \"../types\";\n\n@customElement(\"hass-subpage\")\nclass HassSubpage extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public header?: string;\n\n  @property({ type: Boolean, attribute: \"main-page\" }) public mainPage = false;\n\n  @property({ type: String, attribute: \"back-path\" }) public backPath?: string;\n\n  @property() public backCallback?: () => void;\n\n  @property({ type: Boolean, reflect: true }) public narrow = false;\n\n  @property({ type: Boolean }) public supervisor = false;\n\n  // @ts-ignore\n  @restoreScroll(\".content\") private _savedScrollPos?: number;\n\n  protected willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n    if (!changedProps.has(\"hass\")) {\n      return;\n    }\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    if (!oldHass || oldHass.locale !== this.hass.locale) {\n      toggleAttribute(this, \"rtl\", computeRTL(this.hass));\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"toolbar\">\n        ${this.mainPage || history.state?.root\n          ? html`\n              <ha-menu-button\n                .hassio=${this.supervisor}\n                .hass=${this.hass}\n                .narrow=${this.narrow}\n              ></ha-menu-button>\n            `\n          : this.backPath\n          ? html`\n              <a href=${this.backPath}>\n                <ha-icon-button-arrow-prev\n                  .hass=${this.hass}\n                ></ha-icon-button-arrow-prev>\n              </a>\n            `\n          : html`\n              <ha-icon-button-arrow-prev\n                .hass=${this.hass}\n                @click=${this._backTapped}\n              ></ha-icon-button-arrow-prev>\n            `}\n\n        <div class=\"main-title\">${this.header}</div>\n        <slot name=\"toolbar-icon\"></slot>\n      </div>\n      <div class=\"content\" @scroll=${this._saveScrollPos}><slot></slot></div>\n      <div id=\"fab\">\n        <slot name=\"fab\"></slot>\n      </div>\n    `;\n  }\n\n  @eventOptions({ passive: true })\n  private _saveScrollPos(e: Event) {\n    this._savedScrollPos = (e.target as HTMLDivElement).scrollTop;\n  }\n\n  private _backTapped(): void {\n    if (this.backCallback) {\n      this.backCallback();\n      return;\n    }\n    history.back();\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        height: 100%;\n        background-color: var(--primary-background-color);\n      }\n\n      :host([narrow]) {\n        width: 100%;\n        position: fixed;\n      }\n\n      .toolbar {\n        display: flex;\n        align-items: center;\n        font-size: 20px;\n        height: var(--header-height);\n        padding: 0 16px;\n        pointer-events: none;\n        background-color: var(--app-header-background-color);\n        font-weight: 400;\n        color: var(--app-header-text-color, white);\n        border-bottom: var(--app-header-border-bottom, none);\n        box-sizing: border-box;\n      }\n      .toolbar a {\n        color: var(--sidebar-text-color);\n        text-decoration: none;\n      }\n\n      ha-menu-button,\n      ha-icon-button-arrow-prev,\n      ::slotted([slot=\"toolbar-icon\"]) {\n        pointer-events: auto;\n        color: var(--sidebar-icon-color);\n      }\n\n      .main-title {\n        margin: 0 0 0 24px;\n        line-height: 20px;\n        flex-grow: 1;\n      }\n\n      .content {\n        position: relative;\n        width: 100%;\n        height: calc(100% - 1px - var(--header-height));\n        overflow-y: auto;\n        overflow: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      #fab {\n        position: fixed;\n        right: calc(16px + env(safe-area-inset-right));\n        bottom: calc(16px + env(safe-area-inset-bottom));\n        z-index: 1;\n      }\n      :host([narrow]) #fab.tabs {\n        bottom: calc(84px + env(safe-area-inset-bottom));\n      }\n      #fab[is-wide] {\n        bottom: 24px;\n        right: 24px;\n      }\n      :host([rtl]) #fab {\n        right: auto;\n        left: calc(16px + env(safe-area-inset-left));\n      }\n      :host([rtl][is-wide]) #fab {\n        bottom: 24px;\n        left: 24px;\n        right: auto;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hass-subpage\": HassSubpage;\n  }\n}\n","import { css, html, LitElement } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\n\n@customElement(\"ha-config-section\")\nexport class HaConfigSection extends LitElement {\n  @property() public isWide = false;\n\n  @property({ type: Boolean }) public vertical = false;\n\n  @property({ type: Boolean, attribute: \"full-width\" })\n  public fullWidth = false;\n\n  protected render() {\n    return html`\n      <div\n        class=\"content ${classMap({\n          narrow: !this.isWide,\n          \"full-width\": this.fullWidth,\n        })}\"\n      >\n        <div class=\"header\"><slot name=\"header\"></slot></div>\n        <div\n          class=\"together layout ${classMap({\n            narrow: !this.isWide,\n            vertical: this.vertical || !this.isWide,\n            horizontal: !this.vertical && this.isWide,\n          })}\"\n        >\n          <div class=\"intro\"><slot name=\"introduction\"></slot></div>\n          <div class=\"panel flex-auto\"><slot></slot></div>\n        </div>\n      </div>\n    `;\n  }\n\n  static get styles() {\n    return css`\n      :host {\n        display: block;\n      }\n      .content {\n        padding: 28px 20px 0;\n        max-width: 1040px;\n        margin: 0 auto;\n      }\n\n      .layout {\n        display: flex;\n      }\n\n      .horizontal {\n        flex-direction: row;\n      }\n\n      .vertical {\n        flex-direction: column;\n      }\n\n      .flex-auto {\n        flex: 1 1 auto;\n      }\n\n      .header {\n        font-family: var(--paper-font-headline_-_font-family);\n        -webkit-font-smoothing: var(\n          --paper-font-headline_-_-webkit-font-smoothing\n        );\n        font-size: var(--paper-font-headline_-_font-size);\n        font-weight: var(--paper-font-headline_-_font-weight);\n        letter-spacing: var(--paper-font-headline_-_letter-spacing);\n        line-height: var(--paper-font-headline_-_line-height);\n        opacity: var(--dark-primary-opacity);\n      }\n\n      .together {\n        margin-top: 32px;\n      }\n\n      .intro {\n        font-family: var(--paper-font-subhead_-_font-family);\n        -webkit-font-smoothing: var(\n          --paper-font-subhead_-_-webkit-font-smoothing\n        );\n        font-weight: var(--paper-font-subhead_-_font-weight);\n        line-height: var(--paper-font-subhead_-_line-height);\n        width: 100%;\n        opacity: var(--dark-primary-opacity);\n        font-size: 14px;\n        padding-bottom: 20px;\n      }\n\n      .horizontal .intro {\n        max-width: 400px;\n        margin-right: 40px;\n      }\n\n      .panel {\n        margin-top: -24px;\n      }\n\n      .panel ::slotted(*) {\n        margin-top: 24px;\n        display: block;\n      }\n\n      .narrow.content {\n        max-width: 640px;\n      }\n      .narrow .together {\n        margin-top: 20px;\n      }\n      .narrow .intro {\n        padding-bottom: 20px;\n        margin-right: 0;\n        max-width: 500px;\n      }\n\n      .full-width {\n        padding: 0;\n      }\n\n      .full-width .layout {\n        flex-direction: column;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-config-section\": HaConfigSection;\n  }\n}\n","import { ActionDetail } from \"@material/mwc-list/mwc-list-foundation\";\nimport \"@material/mwc-list/mwc-list-item\";\nimport { mdiContentSave, mdiDelete, mdiDotsVertical } from \"@mdi/js\";\nimport \"@polymer/paper-item/paper-icon-item\";\nimport \"@polymer/paper-item/paper-item\";\nimport \"@polymer/paper-item/paper-item-body\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { afterNextRender } from \"../../homeassistant-frontend/src/common/util/render-status\";\nimport { computeDomain } from \"../../homeassistant-frontend/src/common/entity/compute_domain\";\nimport { computeStateName } from \"../../homeassistant-frontend/src/common/entity/compute_state_name\";\nimport { computeRTL } from \"../../homeassistant-frontend/src/common/util/compute_rtl\";\nimport \"../device/insteon-device-picker\";\nimport \"../../homeassistant-frontend/src/layouts/hass-subpage\";\nimport \"../../homeassistant-frontend/src/components/ha-card\";\nimport \"../../homeassistant-frontend/src/components/ha-fab\";\nimport \"../../homeassistant-frontend/src/components/ha-icon-button\";\nimport \"../../homeassistant-frontend/src/components/ha-icon-picker\";\nimport \"../../homeassistant-frontend/src/components/ha-svg-icon\";\nimport \"../../homeassistant-frontend/src/components/ha-textfield\";\nimport \"../../homeassistant-frontend/src/components/ha-checkbox\";\nimport \"../../homeassistant-frontend/src/components/ha-switch\";\nimport {\n  computeDeviceName,\n  DeviceRegistryEntry,\n  fetchDeviceRegistry,\n} from \"../../homeassistant-frontend/src/data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  fetchEntityRegistry,\n  subscribeEntityRegistry,\n} from \"../../homeassistant-frontend/src/data/entity_registry\";\nimport {\n  showConfirmationDialog,\n  showAlertDialog,\n} from \"../../homeassistant-frontend/src/dialogs/generic/show-dialog-box\";\nimport { KeyboardShortcutMixin } from \"../../homeassistant-frontend/src/mixins/keyboard-shortcut-mixin\";\nimport { haStyle } from \"../../homeassistant-frontend/src/resources/styles\";\nimport { HomeAssistant, Route } from \"../../homeassistant-frontend/src/types\";\nimport \"../../homeassistant-frontend/src/panels/config/ha-config-section\";\nimport {\n  Insteon,\n  InsteonScene,\n  InsteonSceneDeviceData,\n  fetchInsteonScene,\n  sceneDataSchema,\n  saveInsteonScene,\n  deleteInsteonScene,\n  InsteonSceneLinkData,\n} from \"../data/insteon\";\nimport \"../../homeassistant-frontend/src/components/ha-form/ha-form\";\nimport { showInsteonSetOnLevelDialog } from \"./show-dialog-insteon-scene-set-on-level\";\nimport { navigate } from \"../../homeassistant-frontend/src/common/navigate\";\n\ninterface DeviceEntitiesLookup {\n  [deviceId: string]: string[];\n}\n\ninterface InsteonSceneEntity {\n  entity_id: string;\n  name: string;\n  is_in_scene: boolean;\n  data1: number;\n  data2: number;\n  data3: number;\n}\n\ninterface InsteonSceneDevice {\n  address: string;\n  device_id: string;\n  name: string | null | undefined;\n  entities: InsteonSceneEntity[];\n}\n\ninterface InsteonToHaDeviceMap {\n  device: DeviceRegistryEntry;\n  entities: { [group: number]: EntityRegistryEntry };\n}\n\nconst INCLUDED_DOMAINS = [\"switch\", \"fan\", \"light\", \"lock\"];\nconst DIMMABLE_DOMAINS = [\"light\", \"fan\"];\n\n@customElement(\"insteon-scene-editor\")\nexport class InsteonSceneEditor extends KeyboardShortcutMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public insteon!: Insteon;\n\n  @property() public narrow!: boolean;\n\n  @property() public isWide!: boolean;\n\n  @property() public route!: Route;\n\n  @property() public sceneId: string | null = null;\n\n  @state() public _scene?: InsteonScene;\n\n  @state() private _dirty = false;\n\n  @state() private _errors?: string;\n\n  @state() private _deviceRegistryEntries: DeviceRegistryEntry[] = [];\n\n  @state() private _entityRegistryEntries: EntityRegistryEntry[] = [];\n\n  private _insteonToHaDeviceMap: { [address: string]: InsteonToHaDeviceMap } =\n    {};\n\n  private _haToinsteonDeviceMap: { [deviceId: string]: string } = {};\n\n  private _deviceEntityLookup: DeviceEntitiesLookup = {};\n\n  @state() private _saving = false;\n\n  protected firstUpdated(\n    _changedProperties: Map<string | number | symbol, unknown>\n  ): void {\n    super.firstUpdated(_changedProperties);\n\n    if (!this.hass || !this.insteon) {\n      return;\n    }\n\n    if (!this._scene && this.sceneId) {\n      this._loadScene();\n    } else {\n      this._initNewScene();\n    }\n\n    this._getDeviceRegistryEntries();\n    this._getEntityRegistryEntries();\n\n    //Copied from ha-panel-config to retain consistancy\n    this.style.setProperty(\n      \"--app-header-background-color\",\n      \"var(--sidebar-background-color)\"\n    );\n    this.style.setProperty(\n      \"--app-header-text-color\",\n      \"var(--sidebar-text-color)\"\n    );\n    this.style.setProperty(\n      \"--app-header-border-bottom\",\n      \"1px solid var(--divider-color)\"\n    );\n    this.style.setProperty(\n      \"--ha-card-border-radius\",\n      \"var(--ha-config-card-border-radius, 8px)\"\n    );\n  }\n\n  protected updated(changedProps: PropertyValues): void {\n    super.updated(changedProps);\n\n    if (!this.hass || !this.insteon) {\n      return;\n    }\n\n    if (\n      changedProps.has(\"_deviceRegistryEntries\") ||\n      changedProps.has(\"_entityRegistryEntries\")\n    ) {\n      this._mapDeviceEntities();\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass || !this._scene) {\n      return html``;\n    }\n    const name = this._scene\n      ? this._scene.name\n      : this.insteon.localize(\"scenes.scene.default_name\");\n\n    const devices = this._setSceneDevices();\n    return html`\n      <hass-subpage\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .route=${this.route}\n        .backCallback=${this._backTapped}\n        .header=${name}\n      >\n        <ha-button-menu\n          corner=\"BOTTOM_START\"\n          slot=\"toolbar-icon\"\n          @action=${this._handleMenuAction}\n          activatable\n        >\n          <ha-icon-button\n            slot=\"trigger\"\n            .label=${this.hass.localize(\"ui.common.menu\")}\n            .path=${mdiDotsVertical}\n          ></ha-icon-button>\n\n          <mwc-list-item\n            .disabled=${!this.sceneId}\n            aria-label=${this.insteon.localize(\"scenes.scene.delete\")}\n            class=${classMap({ warning: Boolean(this.sceneId) })}\n            graphic=\"icon\"\n          >\n            ${this.insteon.localize(\"scenes.scene.delete\")}\n            <ha-svg-icon\n              class=${classMap({ warning: Boolean(this.sceneId) })}\n              slot=\"graphic\"\n              .path=${mdiDelete}\n            >\n            </ha-svg-icon>\n          </mwc-list-item>\n        </ha-button-menu>\n        ${this._errors ? html` <div class=\"errors\">${this._errors}</div> ` : \"\"}\n        ${!this.narrow ? html` <span slot=\"header\">${name}</span> ` : \"\"}\n        <div\n          id=\"root\"\n          class=${classMap({\n            rtl: computeRTL(this.hass),\n          })}\n        >\n          <ha-config-section vertical .isWide=${this.isWide}>\n            ${this._saving\n              ? html`<div>\n                  <ha-circular-progress\n                    active\n                    alt=\"Loading\"\n                  ></ha-circular-progress>\n                </div>`\n              : this._showEditorArea(name, devices)}\n          </ha-config-section>\n        </div>\n        <ha-fab\n          slot=\"fab\"\n          .label=${this.insteon.localize(\"scenes.scene.save\")}\n          extended\n          .disabled=${this._saving}\n          @click=${this._saveScene}\n          class=${classMap({ dirty: this._dirty, saving: this._saving })}\n        >\n          <ha-svg-icon slot=\"icon\" .path=${mdiContentSave}></ha-svg-icon>\n        </ha-fab>\n      </hass-subpage>\n    `;\n  }\n\n  private async _getDeviceRegistryEntries(): Promise<void> {\n    const allDevices = await fetchDeviceRegistry(this.hass.connection);\n    this._deviceRegistryEntries = allDevices.filter(\n      (device) =>\n        device.config_entries &&\n        device.config_entries.includes(this.insteon.config_entry.entry_id)\n    );\n  }\n\n  private async _getEntityRegistryEntries(): Promise<void> {\n    const allEntities = await fetchEntityRegistry(this.hass.connection);\n    this._entityRegistryEntries = allEntities.filter(\n      (entity) =>\n        entity.entity_category == null &&\n        entity.config_entry_id == this.insteon.config_entry.entry_id &&\n        INCLUDED_DOMAINS.includes(computeDomain(entity.entity_id))\n    );\n  }\n\n  private _showEditorArea(name, devices) {\n    return html`<div slot=\"introduction\">\n        ${this.insteon.localize(\"scenes.scene.introduction\")}\n      </div>\n      <ha-card outlined>\n        <div class=\"card-content\">\n          <ha-textfield\n            .value=${name}\n            .name=${\"name\"}\n            @change=${this._nameChanged}\n            .label=${this.insteon.localize(\"scenes.scene.name\")}\n          ></ha-textfield>\n        </div>\n      </ha-card>\n\n      <ha-config-section vertical .isWide=${this.isWide}>\n        <div slot=\"header\">\n          ${this.insteon.localize(\"scenes.scene.devices.header\")}\n        </div>\n        <div slot=\"introduction\">\n          ${this.insteon.localize(\"scenes.scene.devices.introduction\")}\n        </div>\n\n        ${devices.map(\n          (device) =>\n            html`\n              <ha-card outlined>\n                <h1 class=\"card-header\">\n                  ${device.name}\n                  <ha-icon-button\n                    .path=${mdiDelete}\n                    .label=${this.hass.localize(\n                      \"ui.panel.config.scene.editor.devices.delete\"\n                    )}\n                    .device_address=${device.address}\n                    @click=${this._deleteDevice}\n                  ></ha-icon-button>\n                </h1>\n                ${!device.entities\n                  ? html` <ha-form .schema=${sceneDataSchema}></ha-form> `\n                  : device.entities.map(\n                      (entity) =>\n                        html`\n                          <paper-icon-item class=\"device-entity\">\n                            <ha-checkbox\n                              .checked=${entity.is_in_scene}\n                              @change=${this._toggleSelection}\n                              .device_address=${device.address}\n                              .group=${entity.data3}\n                            ></ha-checkbox>\n                            <paper-item-body\n                              @click=${this._showSetOnLevel}\n                              .device_address=${device.address}\n                              .group=${entity.data3}\n                            >\n                              ${entity.name}\n                            </paper-item-body>\n                            <ha-switch\n                              .checked=${entity.data1 > 0}\n                              @change=${this._toggleOnLevel}\n                              .device_address=${device.address}\n                              .group=${entity.data3}\n                            ></ha-switch>\n                          </paper-icon-item>\n                        `\n                    )};\n              </ha-card>\n            `\n        )}\n\n        <ha-card\n          outlined\n          .header=${this.insteon.localize(\"scenes.scene.devices.add\")}\n        >\n          <div class=\"card-content\">\n            <insteon-device-picker\n              @value-changed=${this._devicePicked}\n              .hass=${this.hass}\n              .insteon=${this.insteon}\n              .label=${this.insteon.localize(\"scenes.scene.devices.add\")}\n              .includedDomains=${INCLUDED_DOMAINS}\n              .excludeModem=${true}\n            ></insteon-device-picker>\n          </div>\n        </ha-card>\n      </ha-config-section>`;\n  }\n\n  private _setSceneDevices(): InsteonSceneDevice[] {\n    const outputDevices: InsteonSceneDevice[] = [];\n    if (!this._scene) {\n      return [];\n    }\n    for (const [address, links] of Object.entries(this._scene.devices)) {\n      const haDevice = this._insteonToHaDeviceMap[address] || undefined;\n      const deviceEntities = haDevice ? haDevice.entities : {};\n      const theseEntities: InsteonSceneEntity[] = [];\n      let thisDevice: InsteonSceneDevice | undefined = undefined;\n\n      for (const [group, entity] of Object.entries(deviceEntities)) {\n        const insteonEntityData: InsteonSceneDeviceData | undefined =\n          links.find((link) => link.data3 == +group);\n        const data1 = insteonEntityData?.data1 || 0;\n        const data2 = insteonEntityData?.data2 || 28;\n        const data3 = insteonEntityData?.data3 || +group;\n        const is_in_scene = insteonEntityData ? true : false;\n        const stateObj = this.hass.states[entity.entity_id];\n        theseEntities.push({\n          entity_id: entity.entity_id,\n          name: stateObj\n            ? computeStateName(stateObj)\n            : entity.name\n            ? entity.name\n            : entity.original_name,\n          is_in_scene: is_in_scene,\n          data1: data1,\n          data2: data2,\n          data3: +data3,\n        });\n        thisDevice = {\n          address: address,\n          device_id: haDevice.device.id,\n          name: computeDeviceName(\n            haDevice.device,\n            this.hass,\n            this._deviceEntityLookup[haDevice.device.id]\n          ),\n          entities: theseEntities,\n        };\n      }\n      if (thisDevice) {\n        outputDevices.push(thisDevice);\n      }\n    }\n    return outputDevices;\n  }\n\n  private _initNewScene() {\n    this._dirty = false;\n    this._scene = {\n      name: this.insteon.localize(\"scenes.scene.default_name\"),\n      devices: {},\n      group: -1,\n    };\n  }\n\n  private _mapDeviceEntities() {\n    this._insteonToHaDeviceMap = {};\n    this._haToinsteonDeviceMap = {};\n    this._deviceRegistryEntries.map((haDevice) => {\n      const address: string = haDevice.identifiers[0][1];\n      const entities: { [group: number]: EntityRegistryEntry } = {};\n      this._entityRegistryEntries\n        .filter((entity) => entity.device_id == haDevice.id)\n        .map((entity) => {\n          let group = +entity.unique_id.split(\"_\")[1];\n          if (Number.isNaN(group)) {\n            group = 1;\n          }\n          entities[group] = entity;\n        });\n      this._insteonToHaDeviceMap[address] = {\n        device: haDevice,\n        entities: entities,\n      };\n      this._haToinsteonDeviceMap[haDevice.id] = address;\n    });\n    for (const entity of this._entityRegistryEntries) {\n      if (!entity.device_id) {\n        continue;\n      }\n      if (!(entity.device_id in this._deviceEntityLookup)) {\n        this._deviceEntityLookup[entity.device_id] = [];\n      }\n      if (\n        !this._deviceEntityLookup[entity.device_id].includes(entity.entity_id)\n      ) {\n        this._deviceEntityLookup[entity.device_id].push(entity.entity_id);\n      }\n    }\n  }\n\n  private async _handleMenuAction(ev: CustomEvent<ActionDetail>) {\n    switch (ev.detail.index) {\n      case 0:\n        this._deleteTapped();\n        break;\n    }\n  }\n\n  private _showSetOnLevel(ev: Event) {\n    ev.stopPropagation();\n    const address = (ev.currentTarget as any).device_address;\n    const group = (ev.currentTarget as any).group;\n    const device = this._scene!.devices[address];\n    let link = device.find((curr_link) => curr_link.data3 == +group);\n    if (!link) {\n      this._selectEntity(true, device, group);\n      link = device.find((curr_link) => curr_link.data3 == +group);\n    }\n    const haDevice = this._insteonToHaDeviceMap[address];\n    const deviceEntities = haDevice.entities || {};\n    const entity = deviceEntities[+group];\n    if (DIMMABLE_DOMAINS.includes(computeDomain(entity.entity_id))) {\n      this._setOnLevel(\n        address,\n        group,\n        link!.data1,\n        link!.data2 == 0 ? 28 : link!.data2\n      );\n    }\n  }\n\n  private async _setOnLevel(\n    address: string,\n    group: number,\n    on_level: number,\n    ramp_rate: number\n  ): Promise<void> {\n    showInsteonSetOnLevelDialog(this, {\n      hass: this.hass,\n      insteon: this.insteon,\n      title: this.insteon.localize(\"device.actions.add\"),\n      address: address,\n      group: group,\n      value: on_level,\n      ramp_rate: ramp_rate,\n      callback: async (address_out, group_out, on_level_out, ramp_rate_out) =>\n        this._handleSetOnLevel(\n          address_out,\n          group_out,\n          on_level_out,\n          ramp_rate_out\n        ),\n    });\n    history.back();\n  }\n\n  private _handleSetOnLevel(\n    address: string,\n    group: number,\n    on_level: number,\n    ramp_rate: number\n  ) {\n    const device = this._scene!.devices[address];\n    const existing_link = device.find((link) => link.data3 == +group);\n    if (existing_link!.data1 != on_level) {\n      existing_link!.data1 = on_level;\n      this._dirty = true;\n    }\n    if (existing_link!.data2 != ramp_rate) {\n      existing_link!.data2 = ramp_rate;\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._scene = { ...this._scene! };\n    }\n  }\n\n  private async _loadScene() {\n    // let config: SceneConfig;\n    this._scene = await fetchInsteonScene(this.hass, +this.sceneId!);\n    for (const address in Object.keys(this._scene.devices)) {\n      const ha_device = this._deviceRegistryEntries.find(\n        (haDevice) => haDevice.identifiers[0][1] === address\n      );\n      const device_id = ha_device?.id || undefined;\n      if (device_id) {\n        this._pickDevice(device_id);\n      }\n    }\n    this._dirty = false;\n  }\n\n  private _pickDevice(deviceId: string) {\n    const haDevice = this._deviceRegistryEntries.find((haCurrDevice) => {\n      return haCurrDevice.id == deviceId;\n    });\n    const address = haDevice?.identifiers[0][1];\n    if (!address) {\n      return;\n    }\n    if (this._scene!.devices.hasOwnProperty(address)) {\n      return;\n    }\n    const updated_scene: InsteonScene = { ...this._scene! };\n    updated_scene.devices[address] = [];\n    this._scene = { ...updated_scene };\n    this._dirty = true;\n  }\n\n  private _devicePicked(ev: CustomEvent) {\n    const deviceId = ev.detail.value;\n    (ev.target as any).value = \"\";\n    this._pickDevice(deviceId);\n  }\n\n  private _deleteDevice(ev: Event) {\n    const address = (ev.target as any).device_address;\n    const updated_scene: InsteonScene = { ...this._scene! };\n    if (updated_scene.devices.hasOwnProperty(address)) {\n      delete updated_scene.devices[address];\n    }\n    this._scene = { ...updated_scene };\n    this._dirty = true;\n  }\n\n  private _toggleSelection(ev: Event) {\n    const address = (ev.target as any).device_address;\n    const checked = (ev.target as any).checked;\n    const group = (ev.target as any).group;\n    const device = this._scene!.devices[address];\n    this._selectEntity(checked, device, group);\n    this._scene = { ...this._scene! };\n    this._dirty = true;\n  }\n\n  private _selectEntity(\n    checked: boolean,\n    device: InsteonSceneDeviceData[],\n    group: number\n  ) {\n    if (checked) {\n      const existing_link = device.find((link) => link.data3 == +group);\n      if (existing_link) {\n        return;\n      }\n      const link: InsteonSceneDeviceData = {\n        data1: 0,\n        data2: 0,\n        data3: group,\n        has_controller: false,\n        has_responder: false,\n      };\n      device.push(link);\n    } else {\n      const existing_link = device.findIndex((link) => link.data3 == +group);\n      if (existing_link !== -1) {\n        device.splice(existing_link, 1);\n      }\n    }\n    this._dirty = true;\n  }\n\n  private _toggleOnLevel(ev: Event) {\n    const address = (ev.target as any).device_address;\n    const checked = (ev.target as any).checked;\n    const group = (ev.target as any).group;\n    const device = this._scene!.devices[address];\n    let existing_link = device.find((link) => link.data3 == +group);\n    if (!existing_link) {\n      this._selectEntity(true, device, +group);\n      existing_link = device.find((link) => link.data3 == +group);\n    }\n    if (checked) {\n      existing_link!.data1 = 255;\n      const haDevice = this._insteonToHaDeviceMap[address] || undefined;\n      const deviceEntities = haDevice.entities || {};\n      const entity = deviceEntities[+group];\n      if (DIMMABLE_DOMAINS.includes(computeDomain(entity.entity_id))) {\n        existing_link!.data2 = 28;\n      }\n    } else {\n      existing_link!.data1 = 0;\n      existing_link!.data2 = 0;\n    }\n    this._scene = { ...this._scene! };\n    this._dirty = true;\n  }\n\n  private _nameChanged(ev: Event) {\n    ev.stopPropagation();\n    const target = ev.target as any;\n    const name = target.name;\n    if (!name) {\n      return;\n    }\n    let newVal = (ev as CustomEvent).detail?.value ?? target.value;\n    if (target.type === \"number\") {\n      newVal = Number(newVal);\n    }\n    if ((this._scene![name] || \"\") === newVal) {\n      return;\n    }\n    if (!newVal) {\n      delete this._scene![name];\n      this._scene = { ...this._scene! };\n    } else {\n      this._scene = { ...this._scene!, [name]: newVal };\n    }\n    this._scene = { ...this._scene! };\n    this._dirty = true;\n  }\n\n  private _backTapped = async (): Promise<void> => {\n    const result = await this.confirmUnsavedChanged();\n    if (result) {\n      this._goBack();\n    }\n  };\n\n  private _goBack(): void {\n    afterNextRender(() => history.back());\n  }\n\n  private async confirmUnsavedChanged(): Promise<boolean> {\n    if (this._dirty) {\n      const action = showConfirmationDialog(this, {\n        title: this.hass!.localize(\n          \"ui.panel.config.scene.editor.unsaved_confirm_title\"\n        ),\n        text: this.hass!.localize(\n          \"ui.panel.config.scene.editor.unsaved_confirm_text\"\n        ),\n        confirmText: this.hass!.localize(\"ui.common.leave\"),\n        dismissText: this.hass!.localize(\"ui.common.stay\"),\n        destructive: true,\n      });\n      history.back();\n      return action;\n    }\n    return true;\n  }\n\n  private _deleteTapped(): void {\n    showConfirmationDialog(this, {\n      text: this.hass!.localize(\"ui.panel.config.scene.picker.delete_confirm\"),\n      confirmText: this.hass!.localize(\"ui.common.delete\"),\n      dismissText: this.hass!.localize(\"ui.common.cancel\"),\n      confirm: () => this._delete(),\n    });\n    history.back();\n  }\n\n  private async _delete(): Promise<void> {\n    this._saving = true;\n    const sceneId: number = +this.sceneId!;\n    const result = await deleteInsteonScene(this.hass, sceneId!);\n    this._saving = false;\n    if (!result.result) {\n      showAlertDialog(this, {\n        text: this.insteon!.localize(\"common.error.scene_write\"),\n        confirmText: this.hass!.localize(\"ui.common.close\"),\n      });\n      history.back();\n    }\n    history.back();\n  }\n\n  private async _saveScene(): Promise<void> {\n    if (!this._checkDeviceEntitySelections()) {\n      showAlertDialog(this, {\n        text: this.insteon!.localize(\"common.error.scene_device_no_entities\"),\n        confirmText: this.hass!.localize(\"ui.common.close\"),\n      });\n      history.back();\n      return;\n    }\n    this._saving = true;\n    const links: InsteonSceneLinkData[] = [];\n    Object.keys(this._scene!.devices).forEach((address) => {\n      const link_data = this._scene!.devices[address];\n      link_data.forEach((link_info) => {\n        const link = {\n          address: address,\n          data1: link_info.data1,\n          data2: link_info.data2,\n          data3: link_info.data3,\n        };\n        links.push(link);\n      });\n    });\n    const result = await saveInsteonScene(\n      this.hass,\n      this._scene!.group,\n      links,\n      this._scene!.name\n    );\n    this._saving = false;\n    this._dirty = false;\n    if (!result.result) {\n      showAlertDialog(this, {\n        text: this.insteon!.localize(\"common.error.scene_write\"),\n        confirmText: this.hass!.localize(\"ui.common.close\"),\n      });\n      history.back();\n    } else {\n      if (!this.sceneId) {\n        navigate(`/insteon/scene/${result.scene_id}`, { replace: true });\n      }\n    }\n  }\n\n  private _checkDeviceEntitySelections(): boolean {\n    for (const [_, links] of Object.entries(this._scene!.devices)) {\n      if (links.length == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  protected handleKeyboardSave() {\n    this._saveScene();\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      css`\n        ha-card {\n          overflow: hidden;\n        }\n        .errors {\n          padding: 20px;\n          font-weight: bold;\n          color: var(--error-color);\n        }\n        ha-config-section:last-child {\n          padding-bottom: 20px;\n        }\n        .triggers,\n        .script {\n          margin-top: -16px;\n        }\n        .triggers ha-card,\n        .script ha-card {\n          margin-top: 16px;\n        }\n        .add-card mwc-button {\n          display: block;\n          text-align: center;\n        }\n        .card-menu {\n          position: absolute;\n          top: 0;\n          right: 0;\n          z-index: 1;\n          color: var(--primary-text-color);\n        }\n        .rtl .card-menu {\n          right: auto;\n          left: 0;\n        }\n        .card-menu paper-item {\n          cursor: pointer;\n        }\n        paper-icon-item {\n          padding: 8px 16px;\n        }\n        ha-card ha-icon-button {\n          color: var(--secondary-text-color);\n        }\n        .card-header > ha-icon-button {\n          float: right;\n          position: relative;\n          top: -8px;\n        }\n        .device-entity {\n          cursor: pointer;\n        }\n        span[slot=\"introduction\"] a {\n          color: var(--primary-color);\n        }\n        ha-fab {\n          position: relative;\n          bottom: calc(-80px - env(safe-area-inset-bottom));\n          transition: bottom 0.3s;\n        }\n        ha-fab.dirty {\n          bottom: 0;\n        }\n        ha-fab.saving {\n          opacity: var(--light-disabled-opacity);\n        }\n        ha-icon-picker,\n        ha-entity-picker {\n          display: block;\n          margin-top: 8px;\n        }\n        ha-textfield {\n          display: block;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"insteon-scene-editor\": InsteonSceneEditor;\n  }\n}\n"],"names":[],"sourceRoot":""}