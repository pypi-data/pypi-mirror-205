# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/api/attr.lime.ipynb.

# %% auto 0
__all__ = ['pairwise_distances', 'bernoulli_perturb_func', 'gaussian_perturb_func', 'exp_kernel_func', 'LimeBase']

# %% ../../nbs/api/attr.lime.ipynb 3
from ..imports import *
from .base import *
from ..linear_model import Lasso, Ridge, LinearModel

# %% ../../nbs/api/attr.lime.ipynb 5
@partial(jit, static_argnums=(2))
def pairwise_distances(
    x: Array, # [n, k]
    y: Array, # [m, k]
    metric: str = "euclidean" # Supports "euclidean" and "cosine"
) -> Array: # [n, m]
    def euclidean_distances(x: Array, y: Array) -> float:
        XX = jnp.dot(x, x)
        YY = jnp.dot(y, y)
        XY = jnp.dot(x, y)
        dist = jnp.clip(XX - 2 * XY + YY, a_min=0.)
        return jnp.sqrt(dist)
        # return jnp.linalg.norm(x - y, ord=2)
    
    def cosine_distances(x: Array, y: Array) -> float:
        return 1.0 - jnp.dot(x, y) / (jnp.linalg.norm(x) * jnp.linalg.norm(y) + 1e-8)
    
    if metric == "euclidean":
        dists_fn = vmap(vmap(euclidean_distances, in_axes=(None, 0)), in_axes=(0, None))
    elif metric == "cosine":
        dists_fn = vmap(vmap(cosine_distances, in_axes=(None, 0)), in_axes=(0, None))
    else:
        raise ValueError(f"metric='{metric}' not supported")
    
    return dists_fn(x, y)

# %% ../../nbs/api/attr.lime.ipynb 10
def bernoulli_perturb_func(x: Array, prng_key: jrand.PRNGKey, **kwargs) -> Array:
    """Bernoulli perturbation function for LIME"""
    probs = jnp.ones(x.shape) * 0.5
    return jrand.bernoulli(prng_key, p=probs, shape=x.shape)

def gaussian_perturb_func(x: Array, prng_key: jrand.PRNGKey, **kwargs) -> Array:
    """Gaussian perturbation function for LIME"""
    return jrand.normal(prng_key, shape=x.shape) #+ x

# %% ../../nbs/api/attr.lime.ipynb 11
def _perturb_data(
    x: Array, # [1, k]
    n_samples: int,
    perturb_func: Callable[[Array, jrand.PRNGKey], Array],
    prng_key: jrand.PRNGKey,
) -> Array:
    """Perturb data using perturb_func"""
    perturbed_data = vmap(jit(perturb_func))(
        jnp.repeat(x, n_samples, axis=0), 
        jrand.split(prng_key, n_samples)
    ) 
    return jnp.concatenate([x, perturbed_data], axis=0)

# %% ../../nbs/api/attr.lime.ipynb 13
@jit
def exp_kernel_func(dists: Array, kernel_width: float) -> Array:
    """Exponential kernel function for LIME"""
    return jnp.sqrt(jnp.exp(-(dists ** 2) / kernel_width ** 2) + 1e-8)

# %% ../../nbs/api/attr.lime.ipynb 15
def _lime_attribute_single_instance(
    inputs: Array, # [k]
    n_samples: int,
    rng_key: jrand.PRNGKey,
    bb_func: Callable[[Array], Array],
    additional_func_args: Dict,
    input_paramter_name: str,
    perturb_func: Callable[[Array, jrand.PRNGKey, Any], Array],
    kernel_func: Callable[[Array], Array],
    model_regressor: LinearModel,
    pairwise_distances_metric: str,
 ) -> Tuple[Array, Array]: # (Local explanation, intercept)
    # Perturb data
    inputs = inputs.reshape(1, -1)
    data = _perturb_data(inputs, n_samples, perturb_func, rng_key)
    distances = pairwise_distances(data, inputs, metric=pairwise_distances_metric).ravel()
    yss = bb_func(**{input_paramter_name: data}, **additional_func_args)

    if len(yss.shape) == 1:
        yss = yss.reshape(-1, 1)
    if yss.shape != (n_samples + 1, 1):
        raise ValueError("Black-box function must output a single value for each instance.")
    
    # fit a linear model to the perturbed data
    # TODO: implement feature selection
    # https://github.com/marcotcr/lime/blob/fd7eb2e6f760619c29fca0187c07b82157601b32/lime/lime_base.py#L70
    weights = kernel_func(distances)
    assert data.shape == (n_samples + 1, inputs.shape[1])
    assert yss.shape == (n_samples + 1, 1)
    assert weights.shape == (n_samples + 1,)
    model_regressor.fit(data, yss, weights=weights)
    return (model_regressor.coef_, model_regressor.intercept_)

# %% ../../nbs/api/attr.lime.ipynb 16
class LimeBase(Attribution):
    def __init__(
        self,
        func: Callable, # A black-box function to be explained
        additional_func_args: Dict = None, # Additional arguments for the black-box function
        model_regressor = None, # Linear regressor to use in explanation
        kernal_func: Callable = None, # Kernel function for computing similarity
        kernel_width: float = None, # Kernel width for computing similarity. Defaults to (n_features * 0.75)
        perturb_func: Callable = None, # Perturbation function for generating perturbed instances
        input_paramter_name: str = "x", # Name of the input parameter for the black-box function
        pairwise_distances_metric: str = "euclidean", # Metric for computing pairwise distances
    ): 
        super().__init__(func, additional_func_args)
        self.bb_func = func
        self.model_regressor = model_regressor if model_regressor is not None else Ridge(alpha=1)
        self.kernal_func = kernal_func if kernal_func is not None else exp_kernel_func
        self.kernel_width = kernel_width
        self.perturb_func = perturb_func if perturb_func is not None else bernoulli_perturb_func
        self.x_name = input_paramter_name
        self.metric = pairwise_distances_metric

    def attribute(
        self, 
        inputs: Array, 
        n_samples: int = 100,
        rng_key: jrand.PRNGKey = None,
        **kwargs
    ) -> Array:
        """Compute attribution for a given input"""
        if len(inputs.shape) != 2:
            raise ValueError("Inputs shape must be (n_instances, n_features).")
        if rng_key is None:
            rng_key = jrand.PRNGKey(get_config().global_seed)

        kernel_width = self.kernel_width if self.kernel_width is not None else inputs.shape[-1] * 0.75
        kerenl_func = partial(self.kernal_func, kernel_width=kernel_width)
        perturb_func = partial(self.perturb_func, **kwargs)
        additional_func_args = self.additional_func_args if self.additional_func_args is not None else {}
        partialed_lime_func = partial(
            _lime_attribute_single_instance,
            n_samples=n_samples,
            rng_key=rng_key,
            bb_func=self.bb_func,
            additional_func_args=additional_func_args,
            input_paramter_name=self.x_name,
            perturb_func=perturb_func,
            kernel_func=kerenl_func,
            model_regressor=self.model_regressor,
            pairwise_distances_metric=self.metric,
        )

        exp, intercept = vmap(partialed_lime_func)(inputs)
        return (exp, intercept)
