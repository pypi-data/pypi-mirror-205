{"version":3,"sources":["AnimatedText.tsx","chatContainer.tsx","stChat.tsx","index.tsx"],"names":["AnimatedText","text","onComplete","onHeightChange","args","useState","visibleText","setVisibleText","textRef","useRef","completed","setCompleted","useEffect","index","interval","setInterval","length","prevText","current","height","getBoundingClientRect","clearInterval","style","background","theme","secondaryBackgroundColor","border","borderRadius","padding","margin","maxWidth","fontSize","flex","display","ref","ChatContainer","isUser","message","animated","key","isAnimationCompleted","setAnimationCompleted","containerHeightRef","avatarUrl","TypingStyle","styled","Avatar","img","width","props","css","Message","div","whiteSpace","Chat","overflow","src","alt","draggable","Streamlit","setFrameHeight","render","window","innerHeight","console","log","StyledChatContainer","StreamlitComponentBase","withStreamlitConnection","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7a3454f9.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\n\ninterface AnimatedTextProps {\n    text: string;\n    onComplete: () => void;\n    onHeightChange: (height: number) => void;\n    args: any;\n}\n\nconst AnimatedText: React.FC<AnimatedTextProps> = ({ text, onComplete, onHeightChange, args }) => {\n  const [visibleText, setVisibleText] = useState('');\n  const textRef = useRef<HTMLDivElement>(null);\n  const [completed, setCompleted] = useState(false);\n\n  useEffect(() => {\n    if (completed) return;\n\n    let index = 0;\n\n    const interval = setInterval(() => {\n      if (index < text.length) {\n        setVisibleText((prevText) => prevText + text[index]);\n\n        if (textRef.current) {\n          const { height } = textRef.current.getBoundingClientRect();\n          onHeightChange(height);\n        }\n\n        index++;\n      } else {\n        clearInterval(interval);\n        onComplete();\n        setCompleted(true);\n      }\n    }, 10); // Adjust the typing speed here\n\n    return () => clearInterval(interval);\n  }, [text, onComplete, onHeightChange, completed]);\n\n  return (\n    <div\n      style={{\n        background: args.theme.secondaryBackgroundColor,\n        border: '1px solid transparent',\n        borderRadius: '10px',\n        padding: '10px 14px',\n        margin: '5px 20px',\n        maxWidth: '80%',\n        fontSize: '1rem',\n        flex: 1,\n        display: 'flex',\n      }}\n      ref={textRef}\n    >\n      {visibleText}\n    </div>\n  );\n};\n\nexport default AnimatedText;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport styled from \"@emotion/styled\";\nimport { css } from \"@emotion/react\";\nimport AnimatedText from './AnimatedText'; // Assuming both files are in the same folder\nimport { Streamlit } from \"streamlit-component-lib\";\n\ninterface ChatProps {\n  args: {\n    isUser: boolean;\n    message: string;\n    animated: boolean;\n    key: any;\n    theme: any;\n  \n  };\n}\n\ninterface AvatarProps {\n  isUser: boolean;\n}\n\ninterface ChatContainerProps {\n  isUser: boolean;\n}\n\nconst ChatContainer: React.FC<ChatProps> = ({ args }) => {\n  const { isUser, message, animated, key } = args;\n  const [isAnimationCompleted, setAnimationCompleted] = useState(false);\n  const containerHeightRef = useRef(0);\n\n  // Streamlit.setComponentValue(args); // Send the value back to Streamlit\n \n  \n\n\n  let avatarUrl = \"\";\n  if (!isUser) {\n    avatarUrl = `https://api.dicebear.com/6.x/avataaars/svg?seed=Felix&facialHair=beardMajestic&facialHairColor=2c1b18&eyes=happy&hairColor=4a312c&skinColor=d08b5b&style=circle&clothing=shirtVNeck&clothesColor=ffffff&top=curvy`;\n  } else {\n    avatarUrl = `https://api.dicebear.com/6.x/shapes/svg?backgroundType=gradientLinear,solid`;\n  }\n\n  // Styles for the Typing component\n  const TypingStyle = styled(AnimatedText)({\n    background: args.theme.secondaryBackgroundColor,\n  });\n\n  // styles for the avatar image\n  const Avatar = styled.img<AvatarProps>(\n    {\n      border: `1px solid transparent`,\n      borderRadius: \"50%\",\n      height: \"5rem\",\n      width: \"5rem\",\n      margin: 0,\n    },\n    (props: { isUser: boolean }) => {\n      // specific styles\n      if (props.isUser) {\n        return css`\n          height: 4rem;\n          width: 4rem;\n          margin: 0;\n        `;\n      }\n      return css``;\n    }\n  );\n\n  // styles for the message box\n  const Message = styled.div({\n    display: \"inline-block\",\n    background: args.theme.secondaryBackgroundColor,\n    border: \"1px solid transparent\",\n    borderRadius: \"10px\",\n    padding: \"10px 14px\",\n    margin: \"5px 20px\",\n    height: \"auto\",\n    maxWidth: \"70%\",\n    whiteSpace: \"pre-line\",\n  });\n\n  // styles for the container\n  const Chat = styled.div<ChatContainerProps>(\n    {\n      display: \"flex\",\n      flex: 1,\n      maxWidth: \"100vw\",\n      height: \"auto\",\n      overflow: \"auto\",\n    },\n    (props: { isUser: boolean }) => {\n      // specific styles\n      if (props.isUser) {\n        return css`\n        flex-direction: row-reverse;\n        & > div {/\n          text-align: right;\n        }\n      `;\n      }\n      return css``;\n    }\n  );\n\n  const handleAnimationComplete = () => {\n    setAnimationCompleted(true);\n    args.animated=true\n  };\n\n  const updateHeight = (height: number) => {\n    containerHeightRef.current = height;\n    //console.log(containerHeightRef.current)\n    if (height < 80){\n      Streamlit.setFrameHeight(80);\n    }else{\n      Streamlit.setFrameHeight(height);\n    }\n      \n\n  };\n\n  return (\n    <div style={{ height: `${containerHeightRef.current}px` }}>\n      <Chat isUser={isUser}>\n        <Avatar isUser={isUser} src={avatarUrl} alt=\"profile\" draggable=\"false\" />\n        {!isUser && !animated && !isAnimationCompleted ? (\n          <div>\n            <TypingStyle\n              text={message}\n              onComplete={handleAnimationComplete}\n              onHeightChange={updateHeight} // Pass the handler here\n              args={args}\n            />\n          </div>\n        ) : (\n          <Message>{message}</Message>\n        )}\n      </Chat>\n    </div>\n  );\n}\n\nexport default ChatContainer","import {\n  // eslint-disable-next-line \n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\nimport styled from \"@emotion/styled\";\nimport ChatContainer from './chatContainer'\n\nclass Chat extends StreamlitComponentBase {\n\n  public render = (): ReactNode => {\n    Streamlit.setFrameHeight(window.innerHeight)\n    const { isUser, message, animated, key } = this.props.args;\n    console.log(this.props.args)\n    // Streamlit sends us a theme object via props that we can use to ensure\n    // that our component has visuals that match the active theme in a\n    // streamlit app.\n    const { theme } = this.props\n    \n    // Maintain compatibility with older versions of Streamlit that don't send\n    // a theme object.\n    if (!theme) {\n      return <div>Theme is undefined, please check streamlit version.</div>\n    }\n    // Styles for the Typing component\n  const StyledChatContainer = styled(ChatContainer)({\n  });\n    return (\n        <StyledChatContainer args={{ isUser: isUser, message: message, theme: theme, animated: animated, key: key}}/>\n\n    )\n  }\n}\n\nexport default withStreamlitConnection(Chat);\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport Chat from \"./stChat\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <Chat />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}