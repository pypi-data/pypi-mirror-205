import ctypes
import platform
import numpy as np

import os

MODULE_PATH = os.path.dirname(os.path.abspath(__file__))
# Create a data structure to hold the pointer generated by hanceGetModelInfo...

class HanceEngine():
    """
    The HanceEngine is a machine learning audio enhancement module 
    developed by Hance.ai
    """
    
    class Processor():
        def __init__(self, hance_engine : ctypes.CDLL, model_path : str, num_of_channels : int, sample_rate : float):
            self.hance_engine = hance_engine
            
            self.handle = self.hance_engine.hanceCreateProcessor(model_path.encode(), num_of_channels, sample_rate)
            if not self.handle:
                raise Exception("Unable to load HANCE model file.")
            self.num_of_channels = num_of_channels

        def __del__(self):
            self.hance_engine.hanceDeleteProcessor(self.handle)
        
        def process(self, audio_signal : np.array) -> bool:
            """
            Processes audio from a numpy array with the format [samples, channels]. The length of the processed audio
            will normally differ from the input lengt due to latency and block based processing.
            """
            num_of_input_samples = audio_signal.shape[0]
            interleaved_audio = audio_signal.flatten()
            self.hance_engine.hanceAddAudioInterleaved(self.handle, interleaved_audio.ctypes.data_as(ctypes.POINTER(ctypes.c_float)), num_of_input_samples)
            num_of_output_samples = self.hance_engine.hanceGetNumOfPendingSamples(self.handle)
            if num_of_output_samples > 0:
                num_of_output_elements = self.num_of_channels * num_of_output_samples
                PCMArray = ctypes.c_float * num_of_output_elements
                pcm_out = PCMArray(*range(num_of_output_elements))        
                self.hance_engine.hanceGetAudioInterleaved(self.handle, ctypes.cast(pcm_out, ctypes.POINTER(ctypes.c_float)), num_of_output_samples)
                return np.array(pcm_out).reshape(num_of_output_samples, self.num_of_channels)
            else:
                return np.empty((0,0))

        def reset(self):
            self.hance_engine.hanceResetProcessor()

        def get_info(self):
            """
            Returns a processor_info dict with information about the processor.
            """
            processor_info = ProcessorInfo()
            self.hance_engine.hanceGetProcessorInfo(self.handle, ctypes.byref(processor_info))
            
            processor_info_parsed = {}
            for field in processor_info_parsed._fields_:
                processor_info_parsed[field[0]] = getattr(processor_info, field[0])
            return processor_info_parsed

    def __init__(self):
        path_to_binary = self.find_binary()
        
        if not path_to_binary:
            raise Exception("Could not find the HANCE Engine binary.")

        self.hance_engine = ctypes.cdll.LoadLibrary(path_to_binary)
        
        # HANCE_API bool hanceAddLicense (const char* licenseString);
        self.hance_engine.hanceAddLicense.argtypes = [ctypes.c_char_p]
        self.hance_engine.hanceAddLicense.restype = ctypes.c_bool

    	# HANCE_API HanceProcessorHandle hanceCreateProcessor (const char* modelFilepath, int32_t numOfChannels, double sampleRate);
        self.hance_engine.hanceCreateProcessor.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_double]
        self.hance_engine.hanceCreateProcessor.restype = ctypes.c_void_p

    	# HANCE_API void hanceDeleteProcessor (HanceProcessorHandle processorHandle);
        self.hance_engine.hanceDeleteProcessor.argtypes = [ctypes.c_void_p]
        self.hance_engine.hanceDeleteProcessor.restype = None

    	# HANCE_API void hanceAddAudioInterleaved (HanceProcessorHandle processorHandle, const float* interleavedPCM, int32_t numOfSamples);
        self.hance_engine.hanceAddAudioInterleaved.argtypes = [ctypes.c_void_p, ctypes.POINTER (ctypes.c_float), ctypes.c_int32]
        self.hance_engine.hanceAddAudioInterleaved.restype = None

        # HANCE_API int32_t hanceGetNumOfPendingSamples (HanceProcessorHandle processorHandle);
        self.hance_engine.hanceGetNumOfPendingSamples.argtypes = [ctypes.c_void_p]
        self.hance_engine.hanceGetNumOfPendingSamples.restype = ctypes.c_int32

        # HANCE_API bool hanceGetAudioInterleaved (HanceProcessorHandle processorHandle, float* interleavedPCM, int32_t numOfSamples);
        self.hance_engine.hanceGetAudioInterleaved.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_float), ctypes.c_int32]
        self.hance_engine.hanceGetAudioInterleaved.restype = ctypes.c_bool

        # HANCE_API void hanceResetProcessorState (HanceProcessorHandle modelHandle);
        self.hance_engine.hanceResetProcessorState.argtypes = [ctypes.c_void_p]
        self.hance_engine.hanceResetProcessorState.restype = None

        # HANCE_API void hanceGetProcessorInfo (HanceProcessorHandle modelHandle, HanceProcessorInfo* modelInfo);
        self.hance_engine.hanceGetProcessorInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        self.hance_engine.hanceGetProcessorInfo.restype = None

        self.prev_samplerate = None
        self.prev_channels = None
    
    def add_license(self, license_string : str) -> bool:
        return self.hance_engine.hanceAddLicense(license_string.encode())

    def create_processor(self, model_file_path : str, num_of_channels : int, sample_rate : int) -> Processor:
        """
        Creates an audio processor from a HANCE model file.
        """
        model_file_abs_path = model_file_path
        if not os.path.exists(model_file_abs_path):
            #possible a relative path from list_models
            found_model = False
            
            model_file_abs_path = os.path.join(MODULE_PATH, "models", model_file_path)
            if os.path.exists(model_file_abs_path):
                found_model = True
                
            if not found_model:
                #Check the relative path from the github repo
                up_one_folder = os.path.split(MODULE_PATH)[0]
                up_two_folders = os.path.split(up_one_folder)[0]
                model_file_abs_path = os.path.join(up_two_folders, "Models", model_file_path)
                print(model_file_abs_path)
                if os.path.exists(model_file_abs_path):
                    found_model = True
                
            if not found_model:
                raise Exception("Model file does not exist.")

        return self.Processor (self.hance_engine, model_file_abs_path, num_of_channels, sample_rate)

    def find_binary(self) -> str:
        """
        Returns the path to a binary in the bin folder.
        """
        
        relative_path = os.path.join(MODULE_PATH, "bin")
        if not os.path.exists(relative_path):
            #We run from the source folder in the github repo
            #Go up one folder and find the Bin folder
            up_one_folder = os.path.split(MODULE_PATH)[0]
            up_two_folders = os.path.split(up_one_folder)[0]
            
            relative_path = os.path.join(up_two_folders, "Bin")
            
        path_to_binary = None
        if platform.system() == "Windows":
            if platform.architecture()[0] == '32bit':
                path_to_binary = os.path.join(relative_path, "Windows_x86/HanceEngine.dll")
            if platform.architecture()[0] == '64bit':
                path_to_binary = os.path.join(relative_path, "Windows_x64/HanceEngine.dll")
        elif platform.system() == "Darwin":
            path_to_binary = os.path.join(relative_path, "macOS/HanceEngine.dylib")
        elif platform.system() == "Linux":
            path_to_binary = os.path.join(relative_path, "Linux/libHanceEngine.so")
        
        return path_to_binary

class ProcessorInfo(ctypes.Structure):
    """ creates a struct to match hanceModelInfo """

    _fields_ = [
                ('sampleRate', ctypes.c_double),
                ('numOfModelChannels', ctypes.c_int32),
                ('latencyInSamples', ctypes.c_int32)
                ]

def list_models():
    """
    Returns a list of available models.
    """
    model_list = []
    model_path = os.path.join(MODULE_PATH, "models")
    if not os.path.exists(model_path):
        #We run from the source folder in the github repo
        up_one_folder = os.path.split(MODULE_PATH)[0]
        up_two_folders = os.path.split(up_one_folder)[0]
        model_path = os.path.join(up_two_folders, "Models")
    
    for fn in os.listdir(model_path):
        if fn.endswith(".hance"):
            model_list.append(fn)
    return model_list